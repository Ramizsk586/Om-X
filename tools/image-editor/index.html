<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Om-X Image Editor</title>
  <style>
    :root {
      --bg: #202124;
      --panel: #3a3a3a;
      --panel-2: #2f2f2f;
      --panel-3: #262626;
      --border: #4b4b4b;
      --border-soft: #444;
      --text: #e6e6e6;
      --muted: #b6b6b6;
      --accent: #c10b0b;
      --canvas-bg: #1d1e21;
      --shadow: 0 10px 24px rgba(0, 0, 0, 0.35);
      --tool-size: 40px;
      --radius: 6px;
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      height: 100%;
      background: #111;
      color: var(--text);
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      overflow: hidden;
    }

    button,
    select,
    input {
      font: inherit;
      color: inherit;
    }

    .editor-shell {
      height: 100vh;
      display: grid;
      grid-template-rows: 42px 46px 1fr;
      background: var(--bg);
      border: 1px solid #1a1a1a;
    }

    .topbar,
    .toolbar {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 0 10px;
      background: #474747;
      border-bottom: 1px solid #3d3d3d;
      min-width: 0;
    }

    .topbar {
      justify-content: space-between;
      background: #4a4a4a;
    }

    .topbar-left {
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 0;
    }

    .menu-btn {
      background: transparent;
      border: 0;
      color: #efefef;
      font-size: 13px;
      padding: 6px 4px;
      border-radius: 4px;
      cursor: default;
      white-space: nowrap;
    }

    .menu-btn:hover {
      background: rgba(255, 255, 255, 0.06);
    }

    .menu-wrap {
      position: relative;
      display: inline-flex;
      align-items: center;
    }

    .menu-dropdown {
      position: absolute;
      top: calc(100% + 6px);
      left: 0;
      min-width: 230px;
      background: #2a2a2a;
      border: 1px solid #4a4a4a;
      border-radius: 8px;
      box-shadow: 0 14px 28px rgba(0, 0, 0, 0.38);
      padding: 6px;
      z-index: 30;
    }

    .menu-dropdown[hidden] {
      display: none;
    }

    .menu-item {
      width: 100%;
      border: 0;
      background: transparent;
      color: #ececec;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      text-align: left;
      padding: 8px 10px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
    }

    .menu-item:hover {
      background: rgba(255, 255, 255, 0.07);
    }

    .menu-item .shortcut {
      color: #bcbcbc;
      font-size: 11px;
      letter-spacing: 0.02em;
    }

    .menu-divider {
      height: 1px;
      background: #424242;
      margin: 6px 4px;
    }

    .toolbar {
      background: #3f3f3f;
      gap: 12px;
      padding-left: 12px;
      overflow-x: auto;
      white-space: nowrap;
    }

    .toolbar::-webkit-scrollbar {
      height: 8px;
    }

    .toolbar::-webkit-scrollbar-thumb {
      background: #5a5a5a;
      border-radius: 999px;
    }

    .tool-group {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-shrink: 0;
    }

    .tool-sep {
      width: 1px;
      height: 24px;
      background: #5a5a5a;
      flex-shrink: 0;
    }

    .toolbar-feature-rail {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-shrink: 0;
      padding-left: 0;
      margin-left: 0;
      border-left: 0;
    }

    .check-row {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: #ececec;
      white-space: nowrap;
    }

    .check-row input {
      accent-color: #1976d2;
      margin: 0;
    }

    .small-select {
      background: #2f2f2f;
      border: 1px solid #545454;
      border-radius: 4px;
      padding: 4px 8px;
      min-width: 84px;
      height: 30px;
    }

    .mini-tool {
      width: 28px;
      height: 28px;
      border-radius: 4px;
      border: 1px solid #575757;
      background: #444;
      color: #e6e6e6;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: default;
      padding: 0;
      font-size: 14px;
    }

    .mini-tool:hover {
      background: #4d4d4d;
    }

    .gradient-controls[hidden] {
      display: none !important;
    }

    .rectangle-controls[hidden] {
      display: none !important;
    }

    .toolbar-pill-label {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 64px;
      height: 28px;
      padding: 0 10px;
      border-radius: 999px;
      border: 1px solid #5a5a5a;
      background: #343434;
      color: #efefef;
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.02em;
    }

    .gradient-select {
      min-width: 94px;
      height: 28px;
      padding-top: 3px;
      padding-bottom: 3px;
    }

    .gradient-check {
      gap: 5px;
      font-size: 11px;
    }

    .gradient-color-field {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      height: 28px;
      padding: 0 6px 0 5px;
      border-radius: 8px;
      border: 1px solid #575757;
      background: #363636;
      color: #ececec;
      white-space: nowrap;
    }

    .gradient-color-label {
      font-size: 10px;
      font-weight: 700;
      opacity: 0.88;
      min-width: 10px;
      text-align: center;
    }

    .gradient-color-field input[type="color"] {
      width: 22px;
      height: 22px;
      border: 0;
      padding: 0;
      background: transparent;
      cursor: pointer;
    }

    .gradient-color-field input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
    }

    .gradient-color-field input[type="color"]::-webkit-color-swatch {
      border: 1px solid rgba(255, 255, 255, 0.18);
      border-radius: 5px;
    }

    .gradient-range-wrap {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      height: 28px;
      padding: 0 7px;
      border-radius: 8px;
      border: 1px solid #575757;
      background: #363636;
      color: #ececec;
    }

    .gradient-range-label {
      font-size: 10px;
      font-weight: 700;
      opacity: 0.88;
    }

    .gradient-range {
      width: 82px;
      accent-color: #67a3ff;
      margin: 0;
    }

    .gradient-range-value {
      min-width: 34px;
      font-size: 10px;
      color: #d2d7e2;
      text-align: right;
    }

    .gradient-presets {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      padding-left: 2px;
    }

    .gradient-preset-btn {
      width: 26px;
      height: 18px;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: #2f2f2f;
      box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.12);
      cursor: pointer;
      padding: 0;
      position: relative;
    }

    .gradient-preset-btn:hover {
      border-color: rgba(255, 255, 255, 0.26);
    }

    .gradient-preset-btn.active {
      border-color: #8cb8ff;
      box-shadow: 0 0 0 1px rgba(140, 184, 255, 0.25), inset 0 0 0 1px rgba(0, 0, 0, 0.12);
    }

    .workspace {
      display: grid;
      grid-template-columns: 56px 1fr 392px;
      min-height: 0;
      background: var(--canvas-bg);
    }

    .left-rail {
      background: #4b4b4b;
      border-right: 1px solid #343434;
      display: grid;
      grid-auto-rows: min-content;
      justify-content: center;
      align-content: start;
      gap: 6px;
      padding: 8px 6px;
    }

    .tool-btn {
      width: var(--tool-size);
      height: var(--tool-size);
      border: 1px solid transparent;
      border-radius: 4px;
      background: transparent;
      color: #ececec;
      cursor: default;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      padding: 0;
      font-size: 20px;
    }

    .tool-btn:hover {
      background: rgba(255, 255, 255, 0.06);
      border-color: rgba(255, 255, 255, 0.08);
    }

    .tool-btn.active {
      background: rgba(255, 255, 255, 0.08);
      border-color: rgba(255, 255, 255, 0.14);
    }

    .tool-btn .submark {
      position: absolute;
      right: 3px;
      bottom: 3px;
      font-size: 10px;
      color: #d8d8d8;
      opacity: 0.9;
    }

    .center-stage {
      min-width: 0;
      display: grid;
      grid-template-rows: 1fr;
      background: #222427;
      border-right: 1px solid #333;
    }

    .canvas-area {
      position: relative;
      overflow: hidden;
      background:
        radial-gradient(circle at 22% 18%, rgba(255,255,255,0.025), transparent 42%),
        radial-gradient(circle at 82% 76%, rgba(255,255,255,0.018), transparent 34%),
        linear-gradient(180deg, #17181b 0%, #121316 100%);
      min-height: 0;
    }

    .canvas-area::-webkit-scrollbar {
      width: 10px;
      height: 10px;
    }

    .canvas-area::-webkit-scrollbar-thumb {
      background: #3d3f45;
      border-radius: 999px;
    }

    .artboard {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      background: #090a0b;
      border: 0;
      box-shadow: none;
      margin: 0;
      display: block;
      cursor: grab;
      z-index: 1;
    }

    .artboard.no-image {
      cursor: default;
    }

    .artboard.is-dragging {
      cursor: grabbing;
    }

    .artboard.tool-marquee,
    .artboard.tool-marquee.no-image,
    .artboard.tool-marquee.is-dragging,
    .artboard.tool-lasso,
    .artboard.tool-lasso.no-image,
    .artboard.tool-lasso.is-dragging,
    .artboard.tool-crop,
    .artboard.tool-crop.no-image,
    .artboard.tool-crop.is-dragging,
    .artboard.tool-heal,
    .artboard.tool-heal.no-image,
    .artboard.tool-heal.is-dragging,
    .artboard.tool-brush,
    .artboard.tool-brush.no-image,
    .artboard.tool-brush.is-dragging,
    .artboard.tool-eraser,
    .artboard.tool-eraser.no-image,
    .artboard.tool-eraser.is-dragging,
    .artboard.tool-gradient,
    .artboard.tool-gradient.no-image,
    .artboard.tool-gradient.is-dragging,
    .artboard.tool-blur,
    .artboard.tool-blur.no-image,
    .artboard.tool-blur.is-dragging,
    .artboard.tool-dodge,
    .artboard.tool-dodge.no-image,
    .artboard.tool-dodge.is-dragging,
    .artboard.tool-pen,
    .artboard.tool-pen.no-image,
    .artboard.tool-pen.is-dragging {
      cursor: crosshair;
    }

    .artboard.tool-path-select,
    .artboard.tool-path-select.no-image {
      cursor: default;
    }

    .artboard.tool-rectangle,
    .artboard.tool-rectangle.no-image,
    .artboard.tool-rectangle.is-dragging {
      cursor: crosshair;
    }

    .artboard.tool-type,
    .artboard.tool-type.no-image,
    .artboard.tool-type.is-dragging {
      cursor: text;
    }

    .artboard-label {
      position: absolute;
      left: 18px;
      bottom: 14px;
      color: #aeb3c0;
      font-size: 11px;
      opacity: 0.8;
      z-index: 3;
    }

    .right-sidebar {
      background: #494949;
      display: grid;
      grid-template-columns: 1fr;
      min-width: 0;
    }

    .right-rail {
      border-right: 1px solid #3b3b3b;
      padding: 8px 4px;
      display: grid;
      grid-auto-rows: min-content;
      align-content: start;
      gap: 6px;
      background: #444;
    }

    .right-rail-btn {
      height: 48px;
      border: 1px solid #5a5a5a;
      background: #3e3e3e;
      color: #ededed;
      border-radius: 4px;
      cursor: default;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 21px;
      padding: 0;
    }

    .right-rail-btn:hover {
      background: #474747;
    }

    .panels {
      min-width: 0;
      display: grid;
      grid-template-rows: minmax(0, 1fr);
      gap: 8px;
      padding: 8px;
      background: #4b4b4b;
    }

    .panel {
      background: #3d3d3d;
      border: 1px solid #2f2f2f;
      min-height: 0;
      display: grid;
      grid-template-rows: 38px 1fr;
      border-radius: 4px;
      overflow: hidden;
    }

    .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 0 8px;
      background: #2e2e2e;
      border-bottom: 1px solid #3a3a3a;
    }

    .panel-tabs {
      display: flex;
      align-items: center;
      gap: 4px;
      min-width: 0;
    }

    .panel-tab {
      background: transparent;
      border: 0;
      color: #bdbdbd;
      padding: 6px 8px;
      border-radius: 4px;
      cursor: default;
      white-space: nowrap;
    }

    .panel-tab.active {
      color: #f0f0f0;
      background: rgba(255,255,255,0.06);
    }

    .panel-menu-btn {
      width: 30px;
      height: 30px;
      border-radius: 4px;
      border: 1px solid #474747;
      background: #3a3a3a;
      color: #ddd;
      cursor: default;
      padding: 0;
    }

    .panel-body {
      min-height: 0;
      overflow: auto;
      background: #474747;
    }

    .panel-body::-webkit-scrollbar {
      width: 8px;
    }

    .panel-body::-webkit-scrollbar-thumb {
      background: #585858;
      border-radius: 999px;
    }

    .history-list {
      padding: 8px 0;
    }

    .history-item {
      padding: 6px 10px;
      border-bottom: 1px solid rgba(255,255,255,0.03);
      color: #f2f2f2;
      font-size: 12px;
    }

    .history-item.muted {
      color: #cfcfcf;
      opacity: 0.85;
    }

    .swatch-grid {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 6px;
      padding: 10px;
    }

    .swatch {
      aspect-ratio: 1 / 1;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 3px;
      background: #fff;
    }

    .layers-panel {
      display: grid;
      grid-template-rows: auto auto auto 1fr auto;
      min-height: 0;
    }

    .layer-toolbar-row,
    .layer-controls-row,
    .layer-lock-row,
    .layers-footer {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 10px;
      border-bottom: 1px solid rgba(255,255,255,0.04);
      background: #474747;
      flex-wrap: wrap;
    }

    .layer-lock-row {
      gap: 8px;
      color: #d8d8d8;
      font-size: 12px;
    }

    .layer-list {
      min-height: 0;
      overflow: auto;
      padding: 8px 0;
      background: #474747;
    }

    .layer-row {
      display: grid;
      grid-template-columns: 28px 40px 1fr 28px;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      font-size: 12px;
      color: #eee;
      background: rgba(0, 0, 0, 0.05);
      border-top: 1px solid rgba(255,255,255,0.04);
      border-bottom: 1px solid rgba(0,0,0,0.12);
      margin-bottom: 4px;
    }

    .layer-eye,
    .layer-lock {
      display: flex;
      align-items: center;
      justify-content: center;
      color: #dfdfdf;
      font-size: 16px;
    }

    .thumb {
      width: 34px;
      height: 20px;
      border: 1px solid #aaa;
      background: #fff;
    }

    .layer-name {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .chip-select {
      background: #414141;
      border: 1px solid #575757;
      border-radius: 4px;
      padding: 4px 8px;
      height: 30px;
      min-width: 120px;
    }

    .mini-input {
      width: 76px;
      background: #414141;
      border: 1px solid #575757;
      border-radius: 4px;
      padding: 4px 6px;
      height: 30px;
    }

    .soft-label {
      font-size: 12px;
      color: #d5d5d5;
      white-space: nowrap;
    }

    .footer-icon {
      width: 26px;
      height: 26px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      border: 1px solid #5b5b5b;
      background: #3f3f3f;
      color: #eee;
      cursor: default;
      padding: 0;
      font-size: 15px;
    }

    .footer-icon:hover,
    .panel-menu-btn:hover {
      background: #484848;
    }

    .spacer {
      flex: 1;
    }

    .status-strip {
      position: absolute;
      top: 10px;
      right: 14px;
      display: inline-flex;
      gap: 8px;
      align-items: center;
      padding: 6px 8px;
      border-radius: 999px;
      background: rgba(0, 0, 0, 0.22);
      border: 1px solid rgba(255,255,255,0.08);
      font-size: 11px;
      color: #cfd5e3;
      z-index: 3;
    }

    .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #ffca28;
      box-shadow: 0 0 8px rgba(255, 202, 40, 0.5);
    }

    .status-strip[data-tone="success"] .status-dot {
      background: #6ee787;
      box-shadow: 0 0 8px rgba(110, 231, 135, 0.5);
    }

    .status-strip[data-tone="error"] .status-dot {
      background: #ff6b6b;
      box-shadow: 0 0 8px rgba(255, 107, 107, 0.45);
    }

    .stage-hud {
      position: absolute;
      right: 14px;
      bottom: 14px;
      display: inline-flex;
      align-items: center;
      gap: 10px;
      max-width: calc(100% - 28px);
      padding: 8px 10px;
      border-radius: 12px;
      background: rgba(10, 11, 13, 0.78);
      border: 1px solid rgba(255,255,255,0.08);
      backdrop-filter: blur(4px);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.28);
      color: #d7deee;
      font-size: 11px;
      z-index: 3;
    }

    .zoom-pill {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 58px;
      padding: 4px 8px;
      border-radius: 999px;
      background: #151822;
      border: 1px solid #2a2f3f;
      color: #eef2ff;
      font-weight: 700;
      letter-spacing: 0.02em;
      flex-shrink: 0;
    }

    .stage-hint {
      color: #b6bfd3;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    @media (max-width: 1200px) {
      .workspace {
        grid-template-columns: 56px 1fr 320px;
      }
    }

    @media (max-width: 980px) {
      .editor-shell {
        grid-template-rows: 42px 46px 1fr auto;
      }

      .workspace {
        grid-template-columns: 56px 1fr;
        grid-template-rows: 1fr 320px;
      }

      .left-rail {
        grid-row: 1 / span 2;
      }

      .center-stage {
        border-right: 0;
        border-bottom: 1px solid #333;
      }

      .right-sidebar {
        grid-column: 2;
        grid-template-columns: 48px 1fr;
      }
    }

    /* Compact Om-X theme overrides (kept at end to override earlier prototype sizing) */
    :root {
      --bg: #0f1013;
      --panel: #11131a;
      --panel-2: #151822;
      --panel-3: #171922;
      --border: #20222a;
      --border-soft: #2a2d38;
      --text: #eef1ff;
      --muted: #a7adbc;
      --canvas-bg: #0d0f14;
      --tool-size: 34px;
      --radius: 10px;
    }

    html, body {
      width: 100%;
      background: #09090b;
      color: var(--text);
    }

    .editor-shell {
      height: 100%;
      min-height: 0;
      grid-template-rows: 36px 42px minmax(0, 1fr);
      background: #0f1013;
      border: 1px solid #20222a;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.02);
    }

    .topbar,
    .toolbar {
      gap: 6px;
      padding: 0 8px;
      background: #12131a;
      border-bottom: 1px solid #20222a;
    }

    .topbar {
      justify-content: flex-start;
      background: #11131a;
      position: relative;
      z-index: 40;
      overflow: visible;
    }

    .topbar-left {
      gap: 4px;
      overflow: visible;
      white-space: nowrap;
    }

    .menu-btn {
      font-size: 12px;
      line-height: 1;
      padding: 5px 4px;
      border-radius: 6px;
      color: #dce2f5;
    }

    .menu-btn:hover {
      background: #171922;
    }

    .menu-dropdown {
      min-width: 216px;
      background: #12141c;
      border: 1px solid #20222a;
      border-radius: 10px;
      box-shadow: 0 16px 32px rgba(0, 0, 0, 0.42);
    }

    .menu-item {
      font-size: 11px;
      padding: 8px 9px;
      border-radius: 8px;
      color: #e6ebff;
    }

    .menu-item:hover {
      background: #171922;
    }

    .menu-item .shortcut {
      color: #9fa8bf;
      font-size: 10px;
    }

    .menu-divider {
      background: #20222a;
    }

    .toolbar {
      gap: 10px;
      padding-left: 8px;
      background: #0f1013;
    }

    .toolbar::-webkit-scrollbar {
      height: 6px;
    }

    .toolbar::-webkit-scrollbar-thumb {
      background: #2a2d38;
    }

    .tool-group {
      gap: 6px;
    }

    .tool-sep {
      height: 22px;
      background: #252936;
    }

    .check-row {
      gap: 5px;
      font-size: 11px;
      color: #c7cfdf;
    }

    .small-select,
    .chip-select,
    .mini-input {
      height: 28px;
      border-radius: 8px;
      border: 1px solid #2a2d38;
      background: #151822;
      color: #eef1ff;
    }

    .small-select {
      min-width: 76px;
      padding: 4px 8px;
    }

    .chip-select {
      min-width: 104px;
      padding: 4px 8px;
    }

    .mini-input {
      width: 68px;
      padding: 4px 6px;
    }

    .mini-tool {
      width: 28px;
      height: 28px;
      border-radius: 8px;
      border: 1px solid #2a2d38;
      background: #151822;
      color: #dfe5f7;
      font-size: 13px;
    }

    .mini-tool:hover {
      background: #1b1f2c;
      border-color: #33384a;
    }

    .toolbar-pill-label {
      height: 24px;
      min-width: 58px;
      padding: 0 8px;
      border-radius: 999px;
      border-color: #2a2d38;
      background: #151822;
      color: #e7ecff;
      font-size: 10px;
    }

    .gradient-select {
      min-width: 84px;
      height: 24px;
      padding: 2px 6px;
      border-radius: 7px;
      font-size: 11px;
    }

    .gradient-check {
      font-size: 10px;
      color: #c7cfdf;
      gap: 4px;
    }

    .gradient-color-field {
      height: 24px;
      padding: 0 5px 0 4px;
      border-radius: 7px;
      border-color: #2a2d38;
      background: #151822;
      color: #eef1ff;
      gap: 4px;
    }

    .gradient-color-label {
      font-size: 9px;
      color: #cbd4ea;
    }

    .gradient-color-field input[type="color"] {
      width: 18px;
      height: 18px;
    }

    .gradient-color-field input[type="color"]::-webkit-color-swatch {
      border-color: rgba(255, 255, 255, 0.14);
      border-radius: 4px;
    }

    .gradient-range-wrap {
      height: 24px;
      padding: 0 6px;
      border-radius: 7px;
      border-color: #2a2d38;
      background: #151822;
      gap: 5px;
    }

    .gradient-range-label,
    .gradient-range-value {
      font-size: 9px;
      color: #c8d1e7;
    }

    .gradient-range {
      width: 72px;
      accent-color: #6da7ff;
    }

    .gradient-range-value {
      min-width: 30px;
    }

    .gradient-presets {
      gap: 4px;
    }

    .gradient-preset-btn {
      width: 22px;
      height: 16px;
      border-radius: 5px;
      border-color: rgba(255, 255, 255, 0.1);
      background: #151822;
    }

    .gradient-preset-btn.active {
      border-color: #79aeff;
      box-shadow: 0 0 0 1px rgba(121, 174, 255, 0.18), inset 0 0 0 1px rgba(0, 0, 0, 0.14);
    }

    .workspace {
      grid-template-columns: 46px minmax(0, 1fr) clamp(278px, 26vw, 342px);
      background: #0d0f14;
    }

    .left-rail {
      background: #0f1013;
      border-right: 1px solid #20222a;
      gap: 4px;
      padding: 6px 4px;
      overflow-y: auto;
      scrollbar-width: thin;
    }

    .left-rail::-webkit-scrollbar {
      width: 6px;
    }

    .left-rail::-webkit-scrollbar-thumb {
      background: #2a2d38;
      border-radius: 999px;
    }

    .tool-btn {
      width: var(--tool-size);
      height: var(--tool-size);
      border-radius: 8px;
      border: 1px solid transparent;
      color: #dfe5f7;
      font-size: 17px;
    }

    .tool-btn:hover {
      background: #171922;
      border-color: #2b2f3c;
    }

    .tool-btn.active {
      background: #171922;
      border-color: #33384a;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.02);
    }

    .tool-btn .submark {
      right: 2px;
      bottom: 2px;
      font-size: 9px;
      color: #aeb6ca;
    }

    .center-stage {
      background: #0f1013;
      border-right: 1px solid #20222a;
    }

    .canvas-area {
      background:
        radial-gradient(circle at 22% 18%, rgba(83, 113, 195, 0.08), transparent 44%),
        radial-gradient(circle at 82% 76%, rgba(255,255,255,0.012), transparent 36%),
        linear-gradient(180deg, #11131a 0%, #0d0f14 100%);
    }

    .artboard-label {
      left: 10px;
      bottom: 9px;
      max-width: 55%;
      font-size: 10px;
      color: #8f97ab;
    }

    .right-sidebar {
      background: #0f1013;
      grid-template-columns: 1fr;
      border-left: 1px solid #20222a;
    }

    .right-rail {
      background: #0f1013;
      border-right: 1px solid #20222a;
      padding: 6px 1px;
      gap: 4px;
      justify-items: center;
      align-content: start;
      overflow-y: auto;
    }

    .right-rail-btn {
      width: 28px;
      height: 28px;
      border-radius: 8px;
      border: 1px solid transparent;
      background: transparent;
      color: #dfe5f7;
      font-size: 12px;
      font-weight: 600;
      line-height: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
    }

    .right-rail-btn:hover {
      background: #171922;
      border-color: #33384a;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.02);
    }

    .right-rail-btn:focus-visible {
      outline: none;
      border-color: #4d87ff;
      box-shadow: 0 0 0 2px rgba(77, 135, 255, 0.14);
    }

    .toolbar-feature-rail {
      gap: 4px;
      margin-left: 38px;
      padding-left: 10px;
      border-left: 1px solid #20222a;
    }

    .toolbar-feature-rail .right-rail-btn {
      width: 28px;
      height: 28px;
    }

    .panels {
      gap: 5px;
      padding: 7px;
      background: #0f1013;
    }

    .panel {
      background: #11131a;
      border: 1px solid #20222a;
      border-radius: 10px;
      grid-template-rows: 34px 1fr;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.12);
    }

    .panel-header {
      padding: 0 7px;
      gap: 5px;
      background: #101219;
      border-bottom: 1px solid #20222a;
    }

    .panel-tab {
      padding: 4px 7px;
      font-size: 10px;
      color: #a7adbc;
      border-radius: 7px;
    }

    .panel-tab.active {
      color: #eef1ff;
      background: #171922;
    }

    .panel-menu-btn {
      width: 24px;
      height: 24px;
      border-radius: 7px;
      border: 1px solid #2a2d38;
      background: #151822;
      color: #dbe2f5;
    }

    .panel-body {
      background: #11141d;
    }

    .panel-body::-webkit-scrollbar-thumb {
      background: #2a2d38;
    }

    .history-list {
      padding: 6px 0;
    }

    .history-item {
      padding: 5px 8px;
      font-size: 11px;
      color: #e7ecff;
      border-bottom: 1px solid rgba(255, 255, 255, 0.02);
    }

    .history-item.muted {
      color: #95a0b9;
    }

    .swatch-grid {
      gap: 5px;
      padding: 8px;
    }

    .swatch {
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 4px;
    }

    .layer-toolbar-row,
    .layer-controls-row,
    .layer-lock-row,
    .layers-footer {
      gap: 6px;
      padding: 6px 8px;
      background: #11141d;
      border-bottom: 1px solid rgba(255,255,255,0.03);
    }

    .layer-toolbar-row,
    .layer-controls-row {
      flex-wrap: nowrap;
      align-items: center;
    }

    .layer-toolbar-row {
      display: grid;
      grid-template-columns: minmax(0, 1fr) auto 70px;
      gap: 6px;
    }

    .layer-toolbar-row .chip-select {
      min-width: 0;
      max-width: none;
      width: 100%;
      flex: initial;
    }

    .layer-toolbar-row .soft-label {
      justify-self: end;
    }

    .layer-toolbar-row .mini-input {
      width: 70px;
      justify-self: end;
    }

    .layer-controls-row {
      display: grid;
      grid-template-columns: auto 70px 1fr;
      gap: 6px;
    }

    .layer-controls-row .mini-input {
      width: 70px;
    }

    .layer-controls-row .spacer {
      display: none;
    }

    .layer-lock-row,
    .soft-label {
      font-size: 10px;
      color: #b8c0d3;
    }

    .layer-lock-row {
      display: grid;
      grid-template-columns: auto repeat(4, 24px);
      align-items: center;
      justify-content: start;
      gap: 6px;
      white-space: nowrap;
    }

    .layer-lock-row > span:first-child {
      margin-right: 2px;
    }

    .layer-list {
      padding: 5px 4px;
      background: #11141d;
    }

    .layer-row {
      grid-template-columns: 22px 34px 1fr 22px;
      gap: 6px;
      padding: 5px 7px;
      font-size: 10px;
      color: #e7ecff;
      margin: 0 0 4px;
      background: #141823;
      border: 1px solid rgba(255,255,255,0.03);
      border-radius: 8px;
    }

    .layer-row:hover {
      background: #171c29;
      border-color: rgba(255,255,255,0.06);
    }

    .layer-eye,
    .layer-lock {
      font-size: 13px;
      color: #cfd7eb;
    }

    .thumb {
      width: 28px;
      height: 16px;
      border: 1px solid rgba(255,255,255,0.16);
      border-radius: 4px;
      background: #f3f3f3;
    }

    .layer-name {
      color: #eef1ff;
      font-size: 10px;
      font-weight: 500;
    }

    .chip-select {
      min-width: 98px;
      flex: 1 1 auto;
      max-width: 132px;
      height: 26px;
      border-radius: 7px;
      padding: 3px 7px;
    }

    .mini-input {
      width: 70px;
      height: 26px;
      border-radius: 7px;
      padding: 3px 6px;
    }

    .footer-icon {
      width: 24px;
      height: 24px;
      border-radius: 7px;
      border: 1px solid #2a2d38;
      background: #151822;
      color: #dde4f6;
      font-size: 12px;
    }

    .layers-footer {
      display: grid;
      grid-template-columns: repeat(7, minmax(0, 1fr));
      gap: 5px;
      padding: 6px 8px;
      background: #11141d;
      border-top: 1px solid rgba(255,255,255,0.02);
      border-bottom: 0;
    }

    .layers-footer .footer-icon {
      width: 100%;
      min-width: 0;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .footer-icon:hover,
    .panel-menu-btn:hover {
      background: #1b1f2c;
      border-color: #33384a;
    }

    .status-strip {
      top: 8px;
      right: 10px;
      gap: 6px;
      padding: 5px 8px;
      border-radius: 999px;
      max-width: 62%;
      background: rgba(10, 11, 13, 0.78);
      border: 1px solid rgba(255,255,255,0.07);
      font-size: 10px;
      color: #d3daec;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
    }

    .status-dot {
      width: 5px;
      height: 5px;
    }

    .stage-hud {
      right: 10px;
      bottom: 9px;
      gap: 8px;
      max-width: calc(100% - 20px);
      padding: 6px 8px;
      border-radius: 10px;
      background: rgba(10, 11, 13, 0.84);
      border: 1px solid rgba(255,255,255,0.07);
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.2);
      font-size: 10px;
    }

    .zoom-pill {
      min-width: 48px;
      padding: 3px 7px;
      border-radius: 999px;
      font-size: 10px;
      background: #151822;
      border: 1px solid #2a2d38;
      color: #eef1ff;
    }

    .stage-hint {
      color: #aab3c8;
    }

    @media (max-width: 1450px) {
      .workspace {
        grid-template-columns: 42px minmax(0, 1fr) clamp(248px, 25vw, 312px);
      }

      .right-sidebar {
        grid-template-columns: 1fr;
      }

      .right-rail-btn {
        width: 26px;
        height: 26px;
        font-size: 11px;
      }

      .tool-btn {
        width: 30px;
        height: 30px;
        font-size: 15px;
      }

      .toolbar-feature-rail {
        margin-left: 34px;
      }

      .left-rail {
        gap: 3px;
        padding: 5px 3px;
      }

      .stage-hint {
        display: none;
      }
    }

    @media (max-width: 1180px) {
      .editor-shell {
        grid-template-rows: 34px 40px minmax(0, 1fr) auto;
      }

      .workspace {
        grid-template-columns: 42px minmax(0, 1fr);
        grid-template-rows: minmax(0, 1fr) 260px;
      }

      .left-rail {
        grid-row: 1 / span 2;
      }

      .center-stage {
        border-right: 0;
        border-bottom: 1px solid #20222a;
      }

      .right-sidebar {
        grid-column: 2;
        grid-template-columns: 1fr;
        border-left: 0;
      }

      .artboard-label {
        max-width: 75%;
      }
    }

    @media (max-width: 860px) {
      .workspace {
        grid-template-columns: 38px minmax(0, 1fr);
        grid-template-rows: minmax(0, 1fr) 220px;
      }

      .left-rail {
        padding: 4px 2px;
      }

      .tool-btn {
        width: 28px;
        height: 28px;
        font-size: 14px;
        border-radius: 7px;
      }

      .topbar,
      .toolbar {
        padding: 0 6px;
      }

      .toolbar-feature-rail {
        margin-left: 32px;
        padding-left: 6px;
      }

      .menu-btn {
        font-size: 11px;
      }

      .status-strip {
        max-width: 78%;
      }
    }

    /* Hide visible scrollbars but preserve scrolling (wheel/trackpad/keyboard) */
    .topbar-left,
    .toolbar,
    .left-rail,
    .right-rail,
    .panel-body,
    .layer-list {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }

    .topbar-left::-webkit-scrollbar,
    .toolbar::-webkit-scrollbar,
    .left-rail::-webkit-scrollbar,
    .right-rail::-webkit-scrollbar,
    .panel-body::-webkit-scrollbar,
    .layer-list::-webkit-scrollbar {
      width: 0 !important;
      height: 0 !important;
      display: none;
      background: transparent;
    }
  </style>
</head>
<body>
  <div class="editor-shell">
    <header class="topbar">
      <div class="topbar-left">
        <div class="menu-wrap">
          <button class="menu-btn" id="file-menu-btn" type="button" title="File menu" aria-haspopup="menu" aria-expanded="false">File</button>
          <div class="menu-dropdown" id="file-menu-dropdown" role="menu" hidden>
            <button class="menu-item" id="file-import-btn" type="button" role="menuitem" title="Import image">
              <span>Import Image...</span>
              <span class="shortcut">Ctrl+O</span>
            </button>
            <button class="menu-item" id="file-save-btn" type="button" role="menuitem" title="Save changes as PNG">
              <span>Save Changes (PNG)</span>
              <span class="shortcut">Ctrl+S</span>
            </button>
            <div class="menu-divider" aria-hidden="true"></div>
            <button class="menu-item" id="file-new-btn" type="button" role="menuitem" title="New blank canvas">
              <span>New Blank Canvas</span>
              <span class="shortcut">Ctrl+N</span>
            </button>
          </div>
        </div>
        <button class="menu-btn" type="button" title="Edit menu">Edit</button>
        <button class="menu-btn" type="button" title="Image menu">Image</button>
        <button class="menu-btn" type="button" title="Layer menu">Layer</button>
        <button class="menu-btn" type="button" title="Select menu">Select</button>
        <button class="menu-btn" type="button" title="Filter menu">Filter</button>
        <button class="menu-btn" type="button" title="View menu">View</button>
        <button class="menu-btn" type="button" title="Window menu">Window</button>
        <button class="menu-btn" type="button" title="More menu">More</button>
      </div>
    </header>

    <div class="toolbar" aria-label="Top tools toolbar">

      <div class="tool-sep" id="gradient-toolbar-sep" aria-hidden="true" hidden></div>

      <div class="tool-group gradient-controls" id="gradient-controls" aria-label="Gradient controls" hidden>
        <span class="toolbar-pill-label">Gradient</span>

        <select class="small-select gradient-select" id="gradient-type-select" title="Gradient type" aria-label="Gradient type">
          <option value="linear">Linear</option>
          <option value="radial">Radial</option>
        </select>

        <select class="small-select gradient-select" id="gradient-blend-select" title="Blend mode" aria-label="Gradient blend mode">
          <option value="source-over">Normal</option>
          <option value="screen">Screen</option>
          <option value="overlay">Overlay</option>
          <option value="soft-light">Soft Light</option>
          <option value="multiply">Multiply</option>
        </select>

        <label class="check-row gradient-check" title="Fade end color to transparent">
          <input type="checkbox" id="gradient-fade-end">
          <span>Fade</span>
        </label>

        <label class="check-row gradient-check" title="Use third color stop">
          <input type="checkbox" id="gradient-mid-toggle">
          <span>3rd</span>
        </label>

        <label class="gradient-color-field" title="Start color">
          <span class="gradient-color-label">A</span>
          <input type="color" id="gradient-start-color" value="#ff7a59">
        </label>

        <label class="gradient-color-field" id="gradient-mid-color-wrap" title="Middle color" hidden>
          <span class="gradient-color-label">M</span>
          <input type="color" id="gradient-mid-color" value="#ffd166">
        </label>

        <label class="gradient-color-field" title="End color">
          <span class="gradient-color-label">B</span>
          <input type="color" id="gradient-end-color" value="#4ecdc4">
        </label>

        <label class="gradient-range-wrap" title="Gradient opacity">
          <span class="gradient-range-label">Op</span>
          <input class="gradient-range" id="gradient-opacity-range" type="range" min="5" max="100" step="1" value="85">
          <span class="gradient-range-value" id="gradient-opacity-value">85%</span>
        </label>

        <button class="mini-tool" id="gradient-reverse-btn" type="button" title="Reverse gradient colors" aria-label="Reverse gradient colors">&#x21C4;</button>

        <div class="gradient-presets" id="gradient-presets" role="list" aria-label="Gradient presets"></div>
      </div>

      <div class="tool-sep" id="rectangle-toolbar-sep" aria-hidden="true" hidden></div>

      <div class="tool-group rectangle-controls" id="rectangle-controls" aria-label="Rectangle controls" hidden>
        <span class="toolbar-pill-label">Rectangle</span>

        <select class="small-select gradient-select" id="rectangle-blend-select" title="Rectangle blend mode" aria-label="Rectangle blend mode">
          <option value="source-over">Normal</option>
          <option value="screen">Screen</option>
          <option value="overlay">Overlay</option>
          <option value="soft-light">Soft Light</option>
          <option value="multiply">Multiply</option>
        </select>

        <label class="check-row gradient-check" title="Enable fill">
          <input type="checkbox" id="rectangle-fill-enable" checked>
          <span>Fill</span>
        </label>

        <label class="gradient-color-field" title="Fill color">
          <span class="gradient-color-label">F</span>
          <input type="color" id="rectangle-fill-color" value="#84b5ff">
        </label>

        <label class="gradient-range-wrap" title="Fill opacity">
          <span class="gradient-range-label">F Op</span>
          <input class="gradient-range" id="rectangle-fill-opacity-range" type="range" min="0" max="100" step="1" value="18">
          <span class="gradient-range-value" id="rectangle-fill-opacity-value">18%</span>
        </label>

        <label class="check-row gradient-check" title="Enable stroke">
          <input type="checkbox" id="rectangle-stroke-enable" checked>
          <span>Stroke</span>
        </label>

        <label class="gradient-color-field" title="Stroke color">
          <span class="gradient-color-label">S</span>
          <input type="color" id="rectangle-stroke-color" value="#84b5ff">
        </label>

        <label class="gradient-range-wrap" title="Stroke width">
          <span class="gradient-range-label">W</span>
          <input class="gradient-range" id="rectangle-stroke-width-range" type="range" min="0" max="60" step="1" value="3">
          <span class="gradient-range-value" id="rectangle-stroke-width-value">3px</span>
        </label>

        <label class="gradient-range-wrap" title="Stroke opacity">
          <span class="gradient-range-label">S Op</span>
          <input class="gradient-range" id="rectangle-stroke-opacity-range" type="range" min="0" max="100" step="1" value="95">
          <span class="gradient-range-value" id="rectangle-stroke-opacity-value">95%</span>
        </label>

        <label class="gradient-range-wrap" title="Corner radius">
          <span class="gradient-range-label">R</span>
          <input class="gradient-range" id="rectangle-radius-range" type="range" min="0" max="120" step="1" value="16">
          <span class="gradient-range-value" id="rectangle-radius-value">16</span>
        </label>
      </div>

      <div class="toolbar-feature-rail" aria-label="Panels quick access">
        <button class="right-rail-btn" type="button" title="Info Panel" aria-label="Info Panel">i</button>
        <button class="right-rail-btn" type="button" title="Adjustments Panel" aria-label="Adjustments Panel">&#x2699;</button>
        <button class="right-rail-btn" type="button" title="Brush Panel" aria-label="Brush Panel">&#x1F58C;</button>
        <button class="right-rail-btn" type="button" title="Character Panel" aria-label="Character Panel">Tt</button>
        <button class="right-rail-btn" type="button" title="Paragraph Panel" aria-label="Paragraph Panel">&#x00B6;</button>
        <button class="right-rail-btn" type="button" title="CSS Panel" aria-label="CSS Panel">CSS</button>
        <button class="right-rail-btn" type="button" title="Navigator Panel" aria-label="Navigator Panel">&#x1F5BC;</button>
      </div>
    </div>

    <main class="workspace">
      <aside class="left-rail" aria-label="Left toolbar">
        <button class="tool-btn active" id="tool-move" data-tool="move" type="button" title="Move Tool" aria-label="Move Tool">&#x21F1;<span class="submark">&#x25BE;</span></button>
        <button class="tool-btn" id="tool-marquee" data-tool="marquee" type="button" title="Marquee Tool" aria-label="Marquee Tool">&#x25A1;<span class="submark">&#x25BE;</span></button>
        <button class="tool-btn" id="tool-lasso" data-tool="lasso" type="button" title="Lasso Tool" aria-label="Lasso Tool">&#x27F3;<span class="submark">&#x25BE;</span></button>
        <button class="tool-btn" id="tool-crop" data-tool="crop" type="button" title="Crop Tool" aria-label="Crop Tool">&#x2398;<span class="submark">&#x25BE;</span></button>
        <button class="tool-btn" id="tool-heal" data-tool="heal" type="button" title="Spot Healing Brush Tool" aria-label="Spot Healing Brush Tool">&#x2695;<span class="submark">&#x25BE;</span></button>
        <button class="tool-btn" id="tool-brush" data-tool="brush" type="button" title="Brush Tool" aria-label="Brush Tool">&#x1F58C;<span class="submark">&#x25BE;</span></button>
        <button class="tool-btn" id="tool-eraser" data-tool="eraser" type="button" title="Eraser Tool" aria-label="Eraser Tool">&#x232B;<span class="submark">&#x25BE;</span></button>
        <button class="tool-btn" id="tool-gradient" data-tool="gradient" type="button" title="Gradient Tool" aria-label="Gradient Tool">&#x25ED;<span class="submark">&#x25BE;</span></button>
        <button class="tool-btn" id="tool-blur" data-tool="blur" type="button" title="Blur Tool" aria-label="Blur Tool">&#x1F4A7;<span class="submark">&#x25BE;</span></button>
        <button class="tool-btn" id="tool-dodge" data-tool="dodge" type="button" title="Dodge Tool" aria-label="Dodge Tool">&#x2600;<span class="submark">&#x25BE;</span></button>
        <button class="tool-btn" id="tool-pen" data-tool="pen" type="button" title="Pen Tool" aria-label="Pen Tool">&#x270E;<span class="submark">&#x25BE;</span></button>
        <button class="tool-btn" id="tool-type" data-tool="type" type="button" title="Type Tool" aria-label="Type Tool">T<span class="submark">&#x25BE;</span></button>
        <button class="tool-btn" id="tool-path-select" data-tool="path-select" type="button" title="Path Selection Tool" aria-label="Path Selection Tool">&#x2197;<span class="submark">&#x25BE;</span></button>
        <button class="tool-btn" id="tool-rectangle" data-tool="rectangle" type="button" title="Rectangle Tool" aria-label="Rectangle Tool">&#x25AD;<span class="submark">&#x25BE;</span></button>
        <button class="tool-btn" id="tool-hand" data-tool="hand" type="button" title="Hand Tool" aria-label="Hand Tool">&#x270B;<span class="submark">&#x25BE;</span></button>
        <button class="tool-btn" id="tool-zoom" data-tool="zoom" type="button" title="Zoom Tool" aria-label="Zoom Tool">&#x1F50D;<span class="submark">&#x25BE;</span></button>
        <button class="tool-btn" id="tool-default-colors" type="button" title="Default Colors" aria-label="Default Colors">&#x25A3;</button>
        <button class="tool-btn" type="button" title="Keyboard Shortcuts" aria-label="Keyboard Shortcuts">&#x2328;</button>
      </aside>

      <section class="center-stage" aria-label="Canvas workspace">
        <div class="canvas-area">
          <div class="status-strip" id="status-strip" data-tone="info" title="Mock editor prototype">
            <span class="status-dot" aria-hidden="true"></span>
            <span id="status-text">Prototype UI (dummy controls)</span>
          </div>
          <canvas id="editor-canvas" class="artboard" title="Canvas / Artboard" width="1600" height="700"></canvas>
          <div class="stage-hud" id="stage-hud" title="Canvas controls">
            <span class="zoom-pill" id="zoom-readout">100%</span>
            <span class="stage-hint" id="stage-hint">Wheel: pan | Ctrl+Wheel: zoom | Drag: move | Double-click: fit</span>
          </div>
          <div class="artboard-label">Black workspace enabled. Import an image, then drag to move and Ctrl+Wheel to zoom.</div>
        </div>
      </section>

      <aside class="right-sidebar" aria-label="Properties and layers panels">
        <div class="panels">
          <section class="panel">
            <div class="panel-header">
              <div class="panel-tabs">
                <button class="panel-tab active" type="button" title="Layers">Layers</button>
                <button class="panel-tab" type="button" title="Channels">Channels</button>
                <button class="panel-tab" type="button" title="Paths">Paths</button>
              </div>
              <button class="panel-menu-btn" type="button" title="Layers panel menu" aria-label="Layers panel menu">&#x2630;</button>
            </div>

            <div class="panel-body layers-panel">
              <div class="layer-toolbar-row">
                <select class="chip-select" disabled title="Blend mode">
                  <option>Normal</option>
                </select>
                <span class="soft-label">Opacity:</span>
                <input class="mini-input" type="text" value="100%" disabled title="Opacity">
              </div>

              <div class="layer-controls-row">
                <span class="soft-label">Fill:</span>
                <input class="mini-input" type="text" value="100%" disabled title="Fill">
                <div class="spacer"></div>
              </div>

              <div class="layer-lock-row">
                <span>Lock:</span>
                <button class="footer-icon" type="button" title="Lock Transparent Pixels" aria-label="Lock Transparent Pixels">&#x25A6;</button>
                <button class="footer-icon" type="button" title="Lock Image Pixels" aria-label="Lock Image Pixels">&#x1F58C;</button>
                <button class="footer-icon" type="button" title="Lock Position" aria-label="Lock Position">&#x2195;</button>
                <button class="footer-icon" type="button" title="Lock All" aria-label="Lock All">&#x1F512;</button>
              </div>

              <div class="layer-list">
                <div class="layer-row" title="Background layer">
                  <div class="layer-eye" aria-hidden="true">&#x1F441;</div>
                  <div class="thumb" aria-hidden="true"></div>
                  <div class="layer-name">Background</div>
                  <div class="layer-lock" aria-hidden="true">&#x1F512;</div>
                </div>
              </div>

              <div class="layers-footer">
                <button class="footer-icon" type="button" title="Link Layers" aria-label="Link Layers">&#x1F517;</button>
                <button class="footer-icon" type="button" title="Layer Effects" aria-label="Layer Effects">fx</button>
                <button class="footer-icon" type="button" title="Add Layer Mask" aria-label="Add Layer Mask">&#x25A3;</button>
                <button class="footer-icon" type="button" title="New Fill or Adjustment Layer" aria-label="New Fill or Adjustment Layer">&#x25D0;</button>
                <button class="footer-icon" type="button" title="New Group" aria-label="New Group">&#x1F4C1;</button>
                <button class="footer-icon" type="button" title="New Layer" aria-label="New Layer">&#x25A1;</button>
                <button class="footer-icon" type="button" title="Delete Layer" aria-label="Delete Layer">&#x1F5D1;</button>
              </div>
            </div>
          </section>
        </div>
      </aside>
    </main>
  </div>
  <script src="auto_select.js"></script>
  <script src="hand.js"></script>
  <script src="zoom.js"></script>
  <script src="path_selection.js"></script>
  <script src="type_render.js"></script>
  <script>
    (function () {
      const els = {
        fileMenuBtn: document.getElementById('file-menu-btn'),
        fileMenuDropdown: document.getElementById('file-menu-dropdown'),
        fileImportBtn: document.getElementById('file-import-btn'),
        fileSaveBtn: document.getElementById('file-save-btn'),
        fileNewBtn: document.getElementById('file-new-btn'),
        moveAutoSelectToggle: document.getElementById('move-auto-select-toggle'),
        moveAutoSelectTarget: document.getElementById('move-auto-select-target'),
        moveToolBtn: document.getElementById('tool-move'),
        marqueeToolBtn: document.getElementById('tool-marquee'),
        lassoToolBtn: document.getElementById('tool-lasso'),
        cropToolBtn: document.getElementById('tool-crop'),
        healToolBtn: document.getElementById('tool-heal'),
        brushToolBtn: document.getElementById('tool-brush'),
        eraserToolBtn: document.getElementById('tool-eraser'),
        gradientToolBtn: document.getElementById('tool-gradient'),
        rectangleToolBtn: document.getElementById('tool-rectangle'),
        blurToolBtn: document.getElementById('tool-blur'),
        gradientToolbarSep: document.getElementById('gradient-toolbar-sep'),
        gradientControls: document.getElementById('gradient-controls'),
        gradientTypeSelect: document.getElementById('gradient-type-select'),
        gradientBlendSelect: document.getElementById('gradient-blend-select'),
        gradientFadeEndCheckbox: document.getElementById('gradient-fade-end'),
        gradientMidToggleCheckbox: document.getElementById('gradient-mid-toggle'),
        gradientStartColorInput: document.getElementById('gradient-start-color'),
        gradientMidColorWrap: document.getElementById('gradient-mid-color-wrap'),
        gradientMidColorInput: document.getElementById('gradient-mid-color'),
        gradientEndColorInput: document.getElementById('gradient-end-color'),
        gradientOpacityRange: document.getElementById('gradient-opacity-range'),
        gradientOpacityValue: document.getElementById('gradient-opacity-value'),
        gradientReverseBtn: document.getElementById('gradient-reverse-btn'),
        gradientPresets: document.getElementById('gradient-presets'),
        rectangleToolbarSep: document.getElementById('rectangle-toolbar-sep'),
        rectangleControls: document.getElementById('rectangle-controls'),
        rectangleBlendSelect: document.getElementById('rectangle-blend-select'),
        rectangleFillEnable: document.getElementById('rectangle-fill-enable'),
        rectangleFillColor: document.getElementById('rectangle-fill-color'),
        rectangleFillOpacityRange: document.getElementById('rectangle-fill-opacity-range'),
        rectangleFillOpacityValue: document.getElementById('rectangle-fill-opacity-value'),
        rectangleStrokeEnable: document.getElementById('rectangle-stroke-enable'),
        rectangleStrokeColor: document.getElementById('rectangle-stroke-color'),
        rectangleStrokeWidthRange: document.getElementById('rectangle-stroke-width-range'),
        rectangleStrokeWidthValue: document.getElementById('rectangle-stroke-width-value'),
        rectangleStrokeOpacityRange: document.getElementById('rectangle-stroke-opacity-range'),
        rectangleStrokeOpacityValue: document.getElementById('rectangle-stroke-opacity-value'),
        rectangleRadiusRange: document.getElementById('rectangle-radius-range'),
        rectangleRadiusValue: document.getElementById('rectangle-radius-value'),
        dodgeToolBtn: document.getElementById('tool-dodge'),
        penToolBtn: document.getElementById('tool-pen'),
        typeToolBtn: document.getElementById('tool-type'),
        pathSelectToolBtn: document.getElementById('tool-path-select'),
        handToolBtn: document.getElementById('tool-hand'),
        zoomToolBtn: document.getElementById('tool-zoom'),
        defaultColorsBtn: document.getElementById('tool-default-colors'),
        leftToolButtons: Array.from(document.querySelectorAll('.left-rail .tool-btn')),
        canvas: document.getElementById('editor-canvas'),
        canvasArea: document.querySelector('.canvas-area'),
        rightSidebar: document.querySelector('.right-sidebar'),
        historyList: document.getElementById('history-list'),
        statusStrip: document.getElementById('status-strip'),
        statusText: document.getElementById('status-text'),
        zoomReadout: document.getElementById('zoom-readout'),
        stageHint: document.getElementById('stage-hint')
      };

      if (!els.canvas) return;

      const ctx = els.canvas.getContext('2d', { alpha: false });
      const state = {
        dirty: false,
        docName: 'New Project.psd',
        image: null,
        resizeObserver: null,
        activeTool: 'move',
        selection: null,
        cropBox: null,
        healBrush: {
          sizeCanvasPx: 34,
          scratchCanvas: null,
          scratchCtx: null,
          stampCanvas: null,
          stampCtx: null,
          lastSourceOffset: null,
          activeStroke: false
        },
        brush: {
          sizeCanvasPx: 22,
          color: '#0b0b0d',
          opacity: 0.95,
          activeStroke: false,
          lastPoint: null
        },
        eraser: {
          sizeCanvasPx: 30,
          opacity: 1,
          activeStroke: false,
          lastPoint: null
        },
        blur: {
          sizeCanvasPx: 34,
          opacity: 0.9,
          blurPx: 7,
          activeStroke: false
        },
        dodge: {
          sizeCanvasPx: 34,
          opacity: 0.62,
          strength: 0.42,
          activeStroke: false
        },
        pen: {
          path: null,
          previewPoint: null,
          selectedAnchorIndex: -1,
          selectedHandle: null,
          strokeColor: '#84b5ff',
          fillColor: '#84b5ff',
          strokeWidthCanvasPx: 2.8,
          strokeOpacity: 0.95,
          fillOpacity: 0.12
        },
        rectangleTool: {
          nextId: 1,
          selectedId: null,
          shapes: [],
          defaults: {
            blendMode: 'source-over',
            fillEnabled: true,
            fillColor: '#84b5ff',
            fillOpacity: 0.18,
            strokeEnabled: true,
            strokeColor: '#84b5ff',
            strokeWidth: 3,
            strokeOpacity: 0.95,
            radius: 16
          }
        },
        gradient: {
          type: 'linear',
          blendMode: 'source-over',
          startColor: '#ff7a59',
          midColor: '#ffd166',
          endColor: '#4ecdc4',
          useMidStop: false,
          midStop: 0.5,
          fadeEnd: false,
          opacity: 0.85,
          presetId: 'sunset',
          preview: null
        },
        view: {
          scale: 1,
          offsetX: 0,
          offsetY: 0,
          fitScale: 1,
          minScale: 0.02,
          maxScale: 16
        },
        drag: {
          active: false,
          pointerId: null,
          mode: null,
          lassoPoints: null,
          penAnchorIndex: -1,
          penHandleType: null,
          penMoved: false,
          rectShapeId: null,
          rectHandle: null,
          rectMoved: false,
          rectStartImagePoint: null,
          rectStartGeom: null,
          startX: 0,
          startY: 0,
          lastX: 0,
          lastY: 0
        }
      };

      const GRADIENT_PRESETS = [
        { id: 'sunset', label: 'Sunset', stops: ['#ff7a59', '#ffd166', '#ef476f'], useMidStop: true, fadeEnd: false, opacity: 0.85, blendMode: 'source-over' },
        { id: 'ocean', label: 'Ocean', stops: ['#0ea5e9', '#38bdf8', '#34d399'], useMidStop: true, fadeEnd: false, opacity: 0.78, blendMode: 'overlay' },
        { id: 'aurora', label: 'Aurora', stops: ['#22c55e', '#06b6d4', '#8b5cf6'], useMidStop: true, fadeEnd: false, opacity: 0.82, blendMode: 'screen' },
        { id: 'fire', label: 'Fire', stops: ['#f97316', '#facc15', '#ef4444'], useMidStop: true, fadeEnd: false, opacity: 0.88, blendMode: 'overlay' },
        { id: 'rose', label: 'Rose', stops: ['#fb7185', '#f9a8d4'], useMidStop: false, fadeEnd: false, opacity: 0.82, blendMode: 'soft-light' },
        { id: 'mono-fade', label: 'Mono Fade', stops: ['#ffffff', '#ffffff'], useMidStop: false, fadeEnd: true, opacity: 0.9, blendMode: 'screen' },
        { id: 'deep-night', label: 'Deep Night', stops: ['#0f172a', '#1d4ed8', '#67e8f9'], useMidStop: true, fadeEnd: false, opacity: 0.72, blendMode: 'overlay' },
        { id: 'custom', label: 'Custom', stops: ['#ff7a59', '#4ecdc4'], useMidStop: false, fadeEnd: false, opacity: 0.85, blendMode: 'source-over', hidden: true }
      ];

      function setStatus(message, tone) {
        if (els.statusText) els.statusText.textContent = message;
        if (els.statusStrip) els.statusStrip.setAttribute('data-tone', tone || 'info');
      }

      function setDocName(name) {
        state.docName = name || 'Untitled';
      }

      function pushHistory(label, muted) {
        if (!els.historyList) return;
        const row = document.createElement('div');
        row.className = 'history-item' + (muted ? ' muted' : '');
        row.textContent = label;
        els.historyList.prepend(row);
        while (els.historyList.children.length > 8) {
          els.historyList.removeChild(els.historyList.lastElementChild);
        }
      }

      function clamp(value, min, max) {
        return Math.min(max, Math.max(min, value));
      }

      const typeTool = (window.OmxTypeTool && typeof window.OmxTypeTool.create === 'function')
        ? window.OmxTypeTool.create({
            rightSidebarEl: els.rightSidebar,
            canvasEl: els.canvas,
            getImage: function () { return state.image; },
            getImageDrawRect: function () { return getImageDrawRect(); },
            canvasToImage: function (x, y, allowOutside) { return getImagePointFromCanvasPoint(x, y, allowOutside); },
            requestRender: function () { renderStage(); },
            setStatus: function (message, tone) { setStatus(message, tone); },
            pushHistory: function (label, muted) { pushHistory(label, muted); },
            markDirty: function () { state.dirty = true; }
          })
        : null;

      const pathSelectionTool = (window.OmxPathSelectionTool && typeof window.OmxPathSelectionTool.create === 'function')
        ? window.OmxPathSelectionTool.create({
            getPenPath: function () { return state.pen.path; },
            isPenPathUsable: function () { return isPenPathUsable(state.pen.path); },
            getPenBounds: function () { return getPenPointBounds(state.pen.path); },
            hitTestPenPath: function (point, tolerance) { return hitTestPenPathAtCanvasPoint(point, tolerance); },
            movePenPath: function (dx, dy) { return moveEntirePenPath(dx, dy); },
            clearPenPath: function (options) { return clearPenPath(options); },
            clearPenAnchorSelection: function () { clearPenSelection(); },
            requestRender: function () { renderStage(); },
            setStatus: function (message, tone) { setStatus(message, tone); },
            pushHistory: function (label, muted) { pushHistory(label, muted); }
          })
        : null;

      const handTool = (window.OmxHandTool && typeof window.OmxHandTool.create === 'function')
        ? window.OmxHandTool.create({
            hasImage: function () { return !!state.image; },
            panBy: function (dx, dy) { panImage(dx, dy); return true; },
            setStatus: function (message, tone) { setStatus(message, tone); }
          })
        : null;

      const zoomTool = (window.OmxZoomTool && typeof window.OmxZoomTool.create === 'function')
        ? window.OmxZoomTool.create({
            hasImage: function () { return !!state.image; },
            zoomAtPoint: function (x, y, factor) { zoomAtCanvasPoint(x, y, factor); return true; },
            zoomToRect: function (rect) { return zoomToCanvasRect(rect); },
            requestRender: function () { renderStage(); },
            setStatus: function (message, tone) { setStatus(message, tone); }
          })
        : null;

      const autoSelectController = (els.moveAutoSelectToggle && els.moveAutoSelectTarget
        && window.OmxAutoSelect && typeof window.OmxAutoSelect.create === 'function')
        ? window.OmxAutoSelect.create({
            els: {
              checkboxEl: els.moveAutoSelectToggle,
              targetSelectEl: els.moveAutoSelectTarget
            },
            setStatus: function (message, tone) { setStatus(message, tone); },
            requestRender: function () { renderStage(); },
            collectCandidatesAtCanvasPoint: function (canvasPoint) { return collectAutoSelectCandidatesAtCanvasPoint(canvasPoint); },
            collectCandidatesInSelection: function (selection) { return collectAutoSelectCandidatesInSelection(selection); },
            startCandidateDrag: function (candidate, canvasPoint, event) { return startAutoSelectedCandidateDrag(candidate, canvasPoint, event); },
            commitCandidateSelection: function (candidate, context) { return commitAutoSelectedCandidate(candidate, context); },
            createSelectionFromCandidate: function (candidate, sourceSelection) { return createSelectionFromAutoSelectCandidate(candidate, sourceSelection); },
            replaceCanvasSelection: function (selection) { return replaceCanvasSelectionFromAutoSelect(selection); }
          })
        : null;

      function normalizeRect(x1, y1, x2, y2) {
        return {
          kind: 'marquee',
          x: Math.min(x1, x2),
          y: Math.min(y1, y2),
          width: Math.abs(x2 - x1),
          height: Math.abs(y2 - y1)
        };
      }

      function createCropBoxFromPoints(startX, startY, currentX, currentY, constrainSquare) {
        let x2 = currentX;
        let y2 = currentY;
        if (constrainSquare) {
          const dx = currentX - startX;
          const dy = currentY - startY;
          const side = Math.max(Math.abs(dx), Math.abs(dy));
          x2 = startX + (dx < 0 ? -side : side);
          y2 = startY + (dy < 0 ? -side : side);
        }
        const rect = normalizeRect(startX, startY, x2, y2);
        rect.kind = 'crop';
        return rect;
      }

      function distanceBetweenPoints(a, b) {
        const dx = (a.x || 0) - (b.x || 0);
        const dy = (a.y || 0) - (b.y || 0);
        return Math.sqrt((dx * dx) + (dy * dy));
      }

      function clonePoint(p) {
        return { x: p.x, y: p.y };
      }

      function getSelectionBoundsRect(selection) {
        if (!selection) return null;
        if (selection.kind === 'lasso') {
          if (Number.isFinite(selection.x) && Number.isFinite(selection.y) && Number.isFinite(selection.width) && Number.isFinite(selection.height)) {
            return {
              x: Number(selection.x) || 0,
              y: Number(selection.y) || 0,
              width: Math.max(0, Number(selection.width) || 0),
              height: Math.max(0, Number(selection.height) || 0)
            };
          }
          if (Array.isArray(selection.points) && selection.points.length) {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            for (const p of selection.points) {
              if (!p) continue;
              if (p.x < minX) minX = p.x;
              if (p.y < minY) minY = p.y;
              if (p.x > maxX) maxX = p.x;
              if (p.y > maxY) maxY = p.y;
            }
            if (Number.isFinite(minX)) {
              return { x: minX, y: minY, width: Math.max(0, maxX - minX), height: Math.max(0, maxY - minY) };
            }
          }
          return null;
        }
        if (Number.isFinite(selection.x) && Number.isFinite(selection.y) && Number.isFinite(selection.width) && Number.isFinite(selection.height)) {
          return {
            x: Number(selection.x) || 0,
            y: Number(selection.y) || 0,
            width: Math.max(0, Number(selection.width) || 0),
            height: Math.max(0, Number(selection.height) || 0)
          };
        }
        return null;
      }

      function pointInPolygonCanvas(point, polygonPoints) {
        if (!point || !Array.isArray(polygonPoints) || polygonPoints.length < 3) return false;
        const x = Number(point.x) || 0;
        const y = Number(point.y) || 0;
        let inside = false;
        for (let i = 0, j = polygonPoints.length - 1; i < polygonPoints.length; j = i, i += 1) {
          const pi = polygonPoints[i];
          const pj = polygonPoints[j];
          if (!pi || !pj) continue;
          const xi = Number(pi.x) || 0;
          const yi = Number(pi.y) || 0;
          const xj = Number(pj.x) || 0;
          const yj = Number(pj.y) || 0;
          const intersects = ((yi > y) !== (yj > y)) && (x < (((xj - xi) * (y - yi)) / ((yj - yi) || 1e-9)) + xi);
          if (intersects) inside = !inside;
        }
        return inside;
      }

      function isCanvasPointInsideSelection(selection, point) {
        if (!selection || !point) return false;
        if (selection.kind === 'lasso') {
          if (Array.isArray(selection.points) && selection.points.length >= 3) {
            return pointInPolygonCanvas(point, selection.points);
          }
          const b = getSelectionBoundsRect(selection);
          return !!(b && point.x >= b.x && point.x <= (b.x + b.width) && point.y >= b.y && point.y <= (b.y + b.height));
        }
        return point.x >= selection.x && point.x <= (selection.x + selection.width) && point.y >= selection.y && point.y <= (selection.y + selection.height);
      }

      function isCanvasPointInsideActiveSelection(canvasX, canvasY) {
        if (!state.selection) return true;
        return isCanvasPointInsideSelection(state.selection, { x: canvasX, y: canvasY });
      }

      function getSelectionCenterPoint(selection) {
        if (!selection) return null;
        if (selection.kind === 'lasso' && Array.isArray(selection.points) && selection.points.length) {
          let sx = 0, sy = 0, count = 0;
          for (const p of selection.points) {
            if (!p) continue;
            sx += Number(p.x) || 0;
            sy += Number(p.y) || 0;
            count += 1;
          }
          if (count) return { x: sx / count, y: sy / count };
        }
        const b = getSelectionBoundsRect(selection);
        if (!b) return null;
        return { x: b.x + (b.width / 2), y: b.y + (b.height / 2) };
      }

      function getRectIntersectionMetrics(a, b) {
        if (!a || !b) return null;
        const ax1 = Number(a.x) || 0;
        const ay1 = Number(a.y) || 0;
        const ax2 = ax1 + Math.max(0, Number(a.width) || 0);
        const ay2 = ay1 + Math.max(0, Number(a.height) || 0);
        const bx1 = Number(b.x) || 0;
        const by1 = Number(b.y) || 0;
        const bx2 = bx1 + Math.max(0, Number(b.width) || 0);
        const by2 = by1 + Math.max(0, Number(b.height) || 0);
        const ix1 = Math.max(ax1, bx1);
        const iy1 = Math.max(ay1, by1);
        const ix2 = Math.min(ax2, bx2);
        const iy2 = Math.min(ay2, by2);
        const iw = ix2 - ix1;
        const ih = iy2 - iy1;
        const intersectArea = (iw > 0 && ih > 0) ? (iw * ih) : 0;
        const aArea = Math.max(0.0001, (ax2 - ax1) * (ay2 - ay1));
        const bArea = Math.max(0.0001, (bx2 - bx1) * (by2 - by1));
        return {
          hit: intersectArea > 0,
          intersectArea: intersectArea,
          overCandidate: intersectArea / aArea,
          overSelection: intersectArea / bArea
        };
      }

      function measureSelectionOverlapWithCanvasRect(selection, rect) {
        if (!selection || !rect) return null;
        const selBounds = getSelectionBoundsRect(selection);
        if (!selBounds) return null;

        const bboxMetrics = getRectIntersectionMetrics(rect, selBounds);
        if (!bboxMetrics || !bboxMetrics.hit) return null;

        const x = Number(rect.x) || 0;
        const y = Number(rect.y) || 0;
        const w = Math.max(0, Number(rect.width) || 0);
        const h = Math.max(0, Number(rect.height) || 0);
        const points = [
          { x: x, y: y },
          { x: x + (w / 2), y: y },
          { x: x + w, y: y },
          { x: x, y: y + (h / 2) },
          { x: x + (w / 2), y: y + (h / 2) },
          { x: x + w, y: y + (h / 2) },
          { x: x, y: y + h },
          { x: x + (w / 2), y: y + h },
          { x: x + w, y: y + h }
        ];
        let insideCount = 0;
        for (const p of points) {
          if (isCanvasPointInsideSelection(selection, p)) insideCount += 1;
        }
        const sampleCoverage = insideCount / points.length;

        const selCenter = getSelectionCenterPoint(selection);
        const selectionCenterInside = selCenter ? (selCenter.x >= x && selCenter.x <= (x + w) && selCenter.y >= y && selCenter.y <= (y + h)) : false;
        const rectCenterInside = isCanvasPointInsideSelection(selection, { x: x + (w / 2), y: y + (h / 2) });

        const areaConfidence = clamp(
          (sampleCoverage * 0.54) +
          (bboxMetrics.overCandidate * 0.23) +
          (bboxMetrics.overSelection * 0.13) +
          (selectionCenterInside ? 0.06 : 0) +
          (rectCenterInside ? 0.04 : 0),
          0,
          1
        );

        return {
          hit: sampleCoverage > 0 || bboxMetrics.overCandidate > 0.06 || bboxMetrics.overSelection > 0.08 || selectionCenterInside || rectCenterInside,
          sampleCoverage: sampleCoverage,
          bboxCandidateCoverage: clamp(bboxMetrics.overCandidate, 0, 1),
          bboxSelectionCoverage: clamp(bboxMetrics.overSelection, 0, 1),
          selectionCenterInside: selectionCenterInside,
          rectCenterInside: rectCenterInside,
          areaConfidence: areaConfidence
        };
      }

      function snapPointToAngle(origin, point, stepDegrees) {
        if (!origin || !point) return point ? clonePoint(point) : null;
        const dx = point.x - origin.x;
        const dy = point.y - origin.y;
        const dist = Math.sqrt((dx * dx) + (dy * dy));
        if (!Number.isFinite(dist) || dist < 0.0001) {
          return { x: origin.x, y: origin.y };
        }
        const step = ((Number(stepDegrees) || 45) * Math.PI) / 180;
        if (!(step > 0)) return clonePoint(point);
        const angle = Math.atan2(dy, dx);
        const snapped = Math.round(angle / step) * step;
        return {
          x: origin.x + (Math.cos(snapped) * dist),
          y: origin.y + (Math.sin(snapped) * dist)
        };
      }

      function colorToRgbaString(color, alpha, fallbackRgb) {
        const fallback = Array.isArray(fallbackRgb) && fallbackRgb.length === 3 ? fallbackRgb : [255, 255, 255];
        const a = clamp(Number(alpha), 0, 1);
        const raw = String(color || '').trim();
        const hex = raw.match(/^#([0-9a-f]{3}|[0-9a-f]{6})$/i);
        if (hex) {
          let v = hex[1];
          if (v.length === 3) v = v.split('').map(function (ch) { return ch + ch; }).join('');
          const n = parseInt(v, 16);
          const r = (n >> 16) & 255;
          const g = (n >> 8) & 255;
          const b = n & 255;
          return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
        }
        const rgb = raw.match(/^rgba?\(\s*([0-9.]+)\s*,\s*([0-9.]+)\s*,\s*([0-9.]+)/i);
        if (rgb) {
          const r = clamp(Math.round(Number(rgb[1]) || 0), 0, 255);
          const g = clamp(Math.round(Number(rgb[2]) || 0), 0, 255);
          const b = clamp(Math.round(Number(rgb[3]) || 0), 0, 255);
          return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
        }
        return 'rgba(' + fallback[0] + ',' + fallback[1] + ',' + fallback[2] + ',' + a + ')';
      }

      function createRectangleShapeId() {
        const next = Math.max(1, Number(state.rectangleTool && state.rectangleTool.nextId) || 1);
        state.rectangleTool.nextId = next + 1;
        return 'rect-' + next;
      }

      function getRectangleShapes() {
        return (state.rectangleTool && Array.isArray(state.rectangleTool.shapes)) ? state.rectangleTool.shapes : [];
      }

      function getRectangleShapeById(id) {
        if (!id) return null;
        const shapes = getRectangleShapes();
        for (let i = 0; i < shapes.length; i += 1) {
          if (shapes[i] && shapes[i].id === id) return shapes[i];
        }
        return null;
      }

      function getSelectedRectangleShape() {
        return getRectangleShapeById(state.rectangleTool && state.rectangleTool.selectedId);
      }

      function copyRectangleGeometry(shape) {
        if (!shape) return null;
        return {
          x: Number(shape.x) || 0,
          y: Number(shape.y) || 0,
          width: Math.max(0, Number(shape.width) || 0),
          height: Math.max(0, Number(shape.height) || 0)
        };
      }

      function normalizeRectangleGeometry(x1, y1, x2, y2) {
        const minX = Math.min(Number(x1) || 0, Number(x2) || 0);
        const minY = Math.min(Number(y1) || 0, Number(y2) || 0);
        const maxX = Math.max(Number(x1) || 0, Number(x2) || 0);
        const maxY = Math.max(Number(y1) || 0, Number(y2) || 0);
        return {
          x: minX,
          y: minY,
          width: Math.max(0, maxX - minX),
          height: Math.max(0, maxY - minY)
        };
      }

      function ensureRectangleRadiusWithinBounds(shape) {
        if (!shape) return;
        const maxR = Math.max(0, Math.min(Number(shape.width) || 0, Number(shape.height) || 0) / 2);
        shape.radius = clamp(Number(shape.radius) || 0, 0, Math.max(0, maxR));
      }

      function createRectangleShapeFromGeometry(geom) {
        const defaults = (state.rectangleTool && state.rectangleTool.defaults) || {};
        const g = geom || { x: 0, y: 0, width: 0, height: 0 };
        const shape = {
          id: createRectangleShapeId(),
          x: Number(g.x) || 0,
          y: Number(g.y) || 0,
          width: Math.max(0, Number(g.width) || 0),
          height: Math.max(0, Number(g.height) || 0),
          blendMode: String(defaults.blendMode || 'source-over'),
          fillEnabled: defaults.fillEnabled !== false,
          fillColor: String(defaults.fillColor || '#84b5ff'),
          fillOpacity: clamp(Number(defaults.fillOpacity), 0, 1),
          strokeEnabled: defaults.strokeEnabled !== false,
          strokeColor: String(defaults.strokeColor || '#84b5ff'),
          strokeWidth: clamp(Number(defaults.strokeWidth) || 0, 0, 400),
          strokeOpacity: clamp(Number(defaults.strokeOpacity), 0, 1),
          radius: clamp(Number(defaults.radius) || 0, 0, 500)
        };
        ensureRectangleRadiusWithinBounds(shape);
        return shape;
      }

      function setRectangleSelectedId(id, options) {
        const silentRender = !!(options && options.silentRender);
        state.rectangleTool.selectedId = id || null;
        updateRectangleControlsUi();
        if (!silentRender) renderStage();
      }

      function clearRectangleSelection(options) {
        if (!state.rectangleTool || !state.rectangleTool.selectedId) return false;
        state.rectangleTool.selectedId = null;
        updateRectangleControlsUi();
        if (!(options && options.silent)) {
          renderStage();
          setStatus('Rectangle selection cleared.', 'info');
        }
        return true;
      }

      function clearRectangleShapes(options) {
        const shapes = getRectangleShapes();
        const had = shapes.length > 0;
        state.rectangleTool.shapes = [];
        state.rectangleTool.selectedId = null;
        state.drag.rectShapeId = null;
        state.drag.rectHandle = null;
        state.drag.rectMoved = false;
        state.drag.rectStartImagePoint = null;
        state.drag.rectStartGeom = null;
        updateRectangleControlsUi();
        if (had && !(options && options.silent)) {
          renderStage();
          setStatus('Rectangle shapes cleared.', 'info');
        }
        return had;
      }

      function deleteSelectedRectangleShape(options) {
        const selectedId = state.rectangleTool && state.rectangleTool.selectedId;
        if (!selectedId) return false;
        const shapes = getRectangleShapes();
        const idx = shapes.findIndex(function (shape) { return !!shape && shape.id === selectedId; });
        if (idx < 0) {
          state.rectangleTool.selectedId = null;
          updateRectangleControlsUi();
          return false;
        }
        shapes.splice(idx, 1);
        state.rectangleTool.selectedId = null;
        state.drag.rectShapeId = null;
        state.drag.rectHandle = null;
        state.drag.rectMoved = false;
        state.drag.rectStartImagePoint = null;
        state.drag.rectStartGeom = null;
        updateRectangleControlsUi();
        if (!(options && options.silent)) {
          state.dirty = true;
          pushHistory('Delete rectangle');
          renderStage();
          setStatus('Rectangle deleted.', 'success');
        }
        return true;
      }

      function getRectangleControlsTarget() {
        return getSelectedRectangleShape() || (state.rectangleTool && state.rectangleTool.defaults) || null;
      }

      function updateRectangleControlsUi() {
        const target = getRectangleControlsTarget();
        if (!target) return;
        if (els.rectangleBlendSelect) els.rectangleBlendSelect.value = String(target.blendMode || 'source-over');
        if (els.rectangleFillEnable) els.rectangleFillEnable.checked = target.fillEnabled !== false;
        if (els.rectangleFillColor) els.rectangleFillColor.value = String(target.fillColor || '#84b5ff');
        if (els.rectangleFillOpacityRange) {
          const fillOp = clamp(Math.round((Number(target.fillOpacity) || 0) * 100), 0, 100);
          els.rectangleFillOpacityRange.value = String(fillOp);
          if (els.rectangleFillOpacityValue) els.rectangleFillOpacityValue.textContent = fillOp + '%';
        } else if (els.rectangleFillOpacityValue) {
          els.rectangleFillOpacityValue.textContent = Math.round((Number(target.fillOpacity) || 0) * 100) + '%';
        }
        if (els.rectangleStrokeEnable) els.rectangleStrokeEnable.checked = target.strokeEnabled !== false;
        if (els.rectangleStrokeColor) els.rectangleStrokeColor.value = String(target.strokeColor || '#84b5ff');
        if (els.rectangleStrokeWidthRange) {
          const width = clamp(Math.round(Number(target.strokeWidth) || 0), 0, 400);
          els.rectangleStrokeWidthRange.value = String(clamp(width, Number(els.rectangleStrokeWidthRange.min) || 0, Number(els.rectangleStrokeWidthRange.max) || 400));
          if (els.rectangleStrokeWidthValue) els.rectangleStrokeWidthValue.textContent = width + 'px';
        } else if (els.rectangleStrokeWidthValue) {
          els.rectangleStrokeWidthValue.textContent = Math.round(Number(target.strokeWidth) || 0) + 'px';
        }
        if (els.rectangleStrokeOpacityRange) {
          const strokeOp = clamp(Math.round((Number(target.strokeOpacity) || 0) * 100), 0, 100);
          els.rectangleStrokeOpacityRange.value = String(strokeOp);
          if (els.rectangleStrokeOpacityValue) els.rectangleStrokeOpacityValue.textContent = strokeOp + '%';
        } else if (els.rectangleStrokeOpacityValue) {
          els.rectangleStrokeOpacityValue.textContent = Math.round((Number(target.strokeOpacity) || 0) * 100) + '%';
        }
        if (els.rectangleRadiusRange) {
          const radius = clamp(Math.round(Number(target.radius) || 0), 0, 500);
          els.rectangleRadiusRange.value = String(clamp(radius, Number(els.rectangleRadiusRange.min) || 0, Number(els.rectangleRadiusRange.max) || 500));
          if (els.rectangleRadiusValue) els.rectangleRadiusValue.textContent = String(radius);
        } else if (els.rectangleRadiusValue) {
          els.rectangleRadiusValue.textContent = String(Math.round(Number(target.radius) || 0));
        }
      }

      function updateRectangleControlsVisibility() {
        const show = state.activeTool === 'rectangle';
        if (els.rectangleControls) els.rectangleControls.hidden = !show;
        if (els.rectangleToolbarSep) els.rectangleToolbarSep.hidden = !show;
      }

      function buildRoundedRectPath(targetCtx, x, y, width, height, radius) {
        if (!targetCtx) return false;
        const w = Math.max(0, Number(width) || 0);
        const h = Math.max(0, Number(height) || 0);
        if (!(w > 0.01 && h > 0.01)) return false;
        const r = clamp(Number(radius) || 0, 0, Math.min(w, h) / 2);
        const x1 = Number(x) || 0;
        const y1 = Number(y) || 0;
        const x2 = x1 + w;
        const y2 = y1 + h;
        targetCtx.beginPath();
        if (r <= 0.01) {
          targetCtx.rect(x1, y1, w, h);
          return true;
        }
        targetCtx.moveTo(x1 + r, y1);
        targetCtx.lineTo(x2 - r, y1);
        targetCtx.quadraticCurveTo(x2, y1, x2, y1 + r);
        targetCtx.lineTo(x2, y2 - r);
        targetCtx.quadraticCurveTo(x2, y2, x2 - r, y2);
        targetCtx.lineTo(x1 + r, y2);
        targetCtx.quadraticCurveTo(x1, y2, x1, y2 - r);
        targetCtx.lineTo(x1, y1 + r);
        targetCtx.quadraticCurveTo(x1, y1, x1 + r, y1);
        targetCtx.closePath();
        return true;
      }

      function getRectangleCanvasMetrics(shape) {
        if (!shape || !state.image) return null;
        const drawRect = getImageDrawRect();
        if (!drawRect || !drawRect.width || !drawRect.height || !state.image.width || !state.image.height) return null;
        const scaleX = drawRect.width / state.image.width;
        const scaleY = drawRect.height / state.image.height;
        const x = drawRect.x + ((Number(shape.x) || 0) * scaleX);
        const y = drawRect.y + ((Number(shape.y) || 0) * scaleY);
        const w = Math.max(0, (Number(shape.width) || 0) * scaleX);
        const h = Math.max(0, (Number(shape.height) || 0) * scaleY);
        const radiusCanvas = clamp((Number(shape.radius) || 0) * Math.min(scaleX, scaleY), 0, Math.min(w, h) / 2);
        const strokeWidthCanvas = Math.max(0, (Number(shape.strokeWidth) || 0) * Math.min(scaleX, scaleY));
        return {
          x: x,
          y: y,
          width: w,
          height: h,
          radius: radiusCanvas,
          strokeWidth: strokeWidthCanvas
        };
      }

      function renderRectangleShapes() {
        const shapes = getRectangleShapes();
        if (!shapes.length || !state.image) return;

        for (let i = 0; i < shapes.length; i += 1) {
          const shape = shapes[i];
          const m = getRectangleCanvasMetrics(shape);
          if (!m || !(m.width > 0.1 && m.height > 0.1)) continue;
          ctx.save();
          ctx.globalCompositeOperation = String(shape.blendMode || 'source-over');
          if (shape.fillEnabled !== false && Number(shape.fillOpacity || 0) > 0.001) {
            if (buildRoundedRectPath(ctx, m.x, m.y, m.width, m.height, m.radius)) {
              ctx.fillStyle = colorToRgbaString(shape.fillColor || '#84b5ff', Number(shape.fillOpacity || 0.18), [132, 181, 255]);
              ctx.fill();
            }
          }
          if (shape.strokeEnabled !== false && Number(shape.strokeWidth || 0) > 0.001 && Number(shape.strokeOpacity || 0) > 0.001) {
            if (buildRoundedRectPath(ctx, m.x, m.y, m.width, m.height, m.radius)) {
              ctx.lineWidth = Math.max(1, m.strokeWidth || 1);
              ctx.strokeStyle = colorToRgbaString(shape.strokeColor || '#84b5ff', Number(shape.strokeOpacity || 0.95), [132, 181, 255]);
              ctx.stroke();
            }
          }
          ctx.restore();
        }

        const showSelectionOverlay = state.activeTool === 'rectangle'
          || (state.activeTool === 'move' && autoSelectController && typeof autoSelectController.isEnabled === 'function' && autoSelectController.isEnabled())
          || state.activeTool === 'lasso';
        if (!showSelectionOverlay) return;
        const selected = getSelectedRectangleShape();
        if (!selected) return;
        const sm = getRectangleCanvasMetrics(selected);
        if (!sm || !(sm.width > 0.1 && sm.height > 0.1)) return;

        const pad = 6;
        const x1 = sm.x - pad;
        const y1 = sm.y - pad;
        const x2 = sm.x + sm.width + pad;
        const y2 = sm.y + sm.height + pad;
        const w = x2 - x1;
        const h = y2 - y1;

        ctx.save();
        ctx.setLineDash([6, 4]);
        ctx.lineWidth = 1;
        ctx.strokeStyle = 'rgba(255,255,255,0.92)';
        ctx.strokeRect(x1 + 0.5, y1 + 0.5, Math.max(0, w - 1), Math.max(0, h - 1));
        ctx.lineDashOffset = 5;
        ctx.strokeStyle = 'rgba(10,12,18,0.95)';
        ctx.strokeRect(x1 + 0.5, y1 + 0.5, Math.max(0, w - 1), Math.max(0, h - 1));
        ctx.setLineDash([]);

        const handles = getRectangleSelectionHandles(selected);
        for (const handle of handles) {
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(Math.round(handle.x - 3), Math.round(handle.y - 3), 6, 6);
          ctx.strokeStyle = '#15171d';
          ctx.strokeRect(Math.round(handle.x - 3) + 0.5, Math.round(handle.y - 3) + 0.5, 5, 5);
        }
        ctx.restore();
      }

      function getRectangleSelectionHandles(shape) {
        const m = getRectangleCanvasMetrics(shape);
        if (!m) return [];
        const x1 = m.x;
        const y1 = m.y;
        const x2 = m.x + m.width;
        const y2 = m.y + m.height;
        const xm = x1 + (m.width / 2);
        const ym = y1 + (m.height / 2);
        return [
          { name: 'nw', x: x1, y: y1 },
          { name: 'n', x: xm, y: y1 },
          { name: 'ne', x: x2, y: y1 },
          { name: 'w', x: x1, y: ym },
          { name: 'e', x: x2, y: ym },
          { name: 'sw', x: x1, y: y2 },
          { name: 's', x: xm, y: y2 },
          { name: 'se', x: x2, y: y2 }
        ];
      }

      function getRectangleHandleHitAtCanvasPoint(point) {
        const selected = getSelectedRectangleShape();
        if (!point || !selected) return null;
        const handles = getRectangleSelectionHandles(selected);
        const r = 7;
        for (let i = 0; i < handles.length; i += 1) {
          const h = handles[i];
          if (Math.abs(point.x - h.x) <= r && Math.abs(point.y - h.y) <= r) {
            return { kind: 'handle', handle: h.name, shapeId: selected.id };
          }
        }
        return null;
      }

      function hitTestRectangleShapeAtCanvasPoint(point) {
        if (!point || !ctx) return null;
        const shapes = getRectangleShapes();
        for (let i = shapes.length - 1; i >= 0; i -= 1) {
          const shape = shapes[i];
          const m = getRectangleCanvasMetrics(shape);
          if (!m || !(m.width > 0.1 && m.height > 0.1)) continue;
          const pad = Math.max(4, (m.strokeWidth || 0) + 4);
          if (point.x < (m.x - pad) || point.y < (m.y - pad) || point.x > (m.x + m.width + pad) || point.y > (m.y + m.height + pad)) continue;

          let fillHit = false;
          let strokeHit = false;
          ctx.save();
          try {
            if (buildRoundedRectPath(ctx, m.x, m.y, m.width, m.height, m.radius)) {
              if (shape.fillEnabled !== false && Number(shape.fillOpacity || 0) > 0.001 && typeof ctx.isPointInPath === 'function') {
                fillHit = !!ctx.isPointInPath(point.x, point.y);
              }
              if ((!fillHit || shape.strokeEnabled !== false) && typeof ctx.isPointInStroke === 'function') {
                ctx.lineWidth = Math.max(2, (m.strokeWidth || 0) + 8);
                strokeHit = !!ctx.isPointInStroke(point.x, point.y);
              }
            }
          } finally {
            ctx.restore();
          }
          if (fillHit || strokeHit) return { kind: 'shape', shapeId: shape.id, fill: fillHit, stroke: strokeHit };
        }
        return null;
      }

      function updateRectangleShapeFromImagePoints(shape, startPoint, currentPoint, constrainSquare) {
        if (!shape || !startPoint || !currentPoint) return false;
        let x2 = currentPoint.x;
        let y2 = currentPoint.y;
        if (constrainSquare) {
          const dx = currentPoint.x - startPoint.x;
          const dy = currentPoint.y - startPoint.y;
          const side = Math.max(Math.abs(dx), Math.abs(dy));
          x2 = startPoint.x + (dx < 0 ? -side : side);
          y2 = startPoint.y + (dy < 0 ? -side : side);
        }
        const next = normalizeRectangleGeometry(startPoint.x, startPoint.y, x2, y2);
        shape.x = next.x;
        shape.y = next.y;
        shape.width = next.width;
        shape.height = next.height;
        ensureRectangleRadiusWithinBounds(shape);
        return true;
      }

      function moveRectangleShapeFromDrag(shape, startGeom, startPoint, currentPoint) {
        if (!shape || !startGeom || !startPoint || !currentPoint) return false;
        shape.x = (Number(startGeom.x) || 0) + ((Number(currentPoint.x) || 0) - (Number(startPoint.x) || 0));
        shape.y = (Number(startGeom.y) || 0) + ((Number(currentPoint.y) || 0) - (Number(startPoint.y) || 0));
        shape.width = Math.max(0, Number(startGeom.width) || 0);
        shape.height = Math.max(0, Number(startGeom.height) || 0);
        ensureRectangleRadiusWithinBounds(shape);
        return true;
      }

      function resizeRectangleShapeFromHandle(shape, startGeom, handle, currentPoint, constrainSquare) {
        if (!shape || !startGeom || !handle || !currentPoint) return false;
        let x1 = Number(startGeom.x) || 0;
        let y1 = Number(startGeom.y) || 0;
        let x2 = x1 + (Number(startGeom.width) || 0);
        let y2 = y1 + (Number(startGeom.height) || 0);

        if (String(handle).indexOf('w') !== -1) x1 = Number(currentPoint.x) || 0;
        if (String(handle).indexOf('e') !== -1) x2 = Number(currentPoint.x) || 0;
        if (String(handle).indexOf('n') !== -1) y1 = Number(currentPoint.y) || 0;
        if (String(handle).indexOf('s') !== -1) y2 = Number(currentPoint.y) || 0;

        if (constrainSquare && (String(handle).length === 2)) {
          const anchorX = String(handle).indexOf('w') !== -1 ? x2 : x1;
          const anchorY = String(handle).indexOf('n') !== -1 ? y2 : y1;
          const sx = (Number(currentPoint.x) || 0) - anchorX;
          const sy = (Number(currentPoint.y) || 0) - anchorY;
          const side = Math.max(Math.abs(sx), Math.abs(sy));
          const nextX = anchorX + (sx < 0 ? -side : side);
          const nextY = anchorY + (sy < 0 ? -side : side);
          if (String(handle).indexOf('w') !== -1) x1 = nextX; else x2 = nextX;
          if (String(handle).indexOf('n') !== -1) y1 = nextY; else y2 = nextY;
        }

        const next = normalizeRectangleGeometry(x1, y1, x2, y2);
        shape.x = next.x;
        shape.y = next.y;
        shape.width = next.width;
        shape.height = next.height;
        ensureRectangleRadiusWithinBounds(shape);
        return true;
      }

      function cropRectangleShapes(crop) {
        if (!crop) return;
        const shapes = getRectangleShapes();
        if (!shapes.length) return;
        const x1 = Number(crop.srcX) || 0;
        const y1 = Number(crop.srcY) || 0;
        const x2 = x1 + Math.max(1, Number(crop.srcW) || 1);
        const y2 = y1 + Math.max(1, Number(crop.srcH) || 1);
        const nextShapes = [];
        for (const shape of shapes) {
          if (!shape) continue;
          const sx1 = Number(shape.x) || 0;
          const sy1 = Number(shape.y) || 0;
          const sx2 = sx1 + Math.max(0, Number(shape.width) || 0);
          const sy2 = sy1 + Math.max(0, Number(shape.height) || 0);
          const ix1 = Math.max(x1, sx1);
          const iy1 = Math.max(y1, sy1);
          const ix2 = Math.min(x2, sx2);
          const iy2 = Math.min(y2, sy2);
          const iw = ix2 - ix1;
          const ih = iy2 - iy1;
          if (!(iw > 0.5 && ih > 0.5)) continue;
          shape.x = ix1 - x1;
          shape.y = iy1 - y1;
          shape.width = iw;
          shape.height = ih;
          ensureRectangleRadiusWithinBounds(shape);
          nextShapes.push(shape);
        }
        state.rectangleTool.shapes = nextShapes;
        if (!getSelectedRectangleShape()) state.rectangleTool.selectedId = null;
        updateRectangleControlsUi();
      }

      function buildTextAutoSelectCandidateAtCanvasPoint(canvasPoint) {
        if (!canvasPoint || !typeTool) return null;
        if (typeof typeTool._map !== 'function' || typeof typeTool._hit !== 'function') return null;
        const mapped = typeTool._map(canvasPoint.x, canvasPoint.y, true);
        if (!mapped) return null;
        const hit = typeTool._hit(mapped);
        if (!hit || !hit.layer) return null;
        const layer = hit.layer;
        const boundsImage = typeof typeTool.getLayerBoundsImage === 'function' ? typeTool.getLayerBoundsImage(layer) : null;
        const boundsCanvas = imageRectToCanvasRect(boundsImage);
        const zIndex = Array.isArray(typeTool.layers) ? Math.max(0, typeTool.layers.lastIndexOf(layer)) : 0;
        return {
          id: layer.id,
          kind: 'text',
          family: 'text',
          label: (layer.name ? String(layer.name) : 'Text layer'),
          zIndex: 300 + zIndex,
          exactness: 0.78,
          hitKind: 'bounds',
          boundsCanvas: boundsCanvas,
          selected: !!(typeTool.selectedId && typeTool.selectedId === layer.id)
        };
      }

      function buildRectangleAutoSelectCandidateAtCanvasPoint(canvasPoint) {
        if (!canvasPoint) return null;
        const hit = hitTestRectangleShapeAtCanvasPoint(canvasPoint);
        if (!hit || !hit.shapeId) return null;
        const shape = getRectangleShapeById(hit.shapeId);
        if (!shape) return null;
        const boundsCanvas = getRectangleCanvasMetrics(shape);
        const shapeIndex = getRectangleShapes().findIndex(function (s) { return !!s && s.id === shape.id; });
        return {
          id: shape.id,
          kind: 'rectangle',
          family: 'shape',
          label: 'Rectangle',
          zIndex: 100 + Math.max(0, shapeIndex),
          exactness: hit.fill ? 0.95 : (hit.stroke ? 0.88 : 0.72),
          hitKind: hit.fill ? 'fill' : (hit.stroke ? 'stroke' : 'bounds'),
          boundsCanvas: boundsCanvas ? {
            x: boundsCanvas.x,
            y: boundsCanvas.y,
            width: boundsCanvas.width,
            height: boundsCanvas.height
          } : null,
          selected: !!(state.rectangleTool && state.rectangleTool.selectedId === shape.id),
          meta: { shapeId: shape.id }
        };
      }

      function buildPathAutoSelectCandidateAtCanvasPoint(canvasPoint) {
        if (!canvasPoint || !hasPenPath()) return null;
        const hit = hitTestPenPathAtCanvasPoint(canvasPoint, 9);
        if (!hit || !hit.hit) return null;
        const bounds = getPenPointBounds(state.pen.path);
        return {
          id: 'pen-path',
          kind: 'path',
          family: 'shape',
          label: 'Path',
          zIndex: 220,
          exactness: hit.fill ? 0.92 : (hit.stroke ? 0.86 : 0.68),
          hitKind: hit.fill ? 'fill' : (hit.stroke ? 'path' : 'bounds-only'),
          boundsCanvas: bounds ? {
            x: bounds.x,
            y: bounds.y,
            width: bounds.width,
            height: bounds.height
          } : null,
          selected: !!(pathSelectionTool && pathSelectionTool.selected)
        };
      }

      function collectAutoSelectCandidatesAtCanvasPoint(canvasPoint) {
        const candidates = [];
        const textCandidate = buildTextAutoSelectCandidateAtCanvasPoint(canvasPoint);
        if (textCandidate) candidates.push(textCandidate);
        const rectCandidate = buildRectangleAutoSelectCandidateAtCanvasPoint(canvasPoint);
        if (rectCandidate) candidates.push(rectCandidate);
        const pathCandidate = buildPathAutoSelectCandidateAtCanvasPoint(canvasPoint);
        if (pathCandidate) candidates.push(pathCandidate);
        return candidates;
      }

      function enrichCandidateForSelectionArea(candidate, selection) {
        if (!candidate || !candidate.boundsCanvas || !selection) return null;
        const overlap = measureSelectionOverlapWithCanvasRect(selection, candidate.boundsCanvas);
        if (!overlap || !overlap.hit) return null;
        const copy = Object.assign({}, candidate);
        copy.areaConfidence = clamp(Number(overlap.areaConfidence) || 0, 0, 1);
        copy.areaCoverage = clamp(Number(overlap.bboxCandidateCoverage) || 0, 0, 1);
        copy.selectionContain = clamp(Number(overlap.bboxSelectionCoverage) || 0, 0, 1);
        copy.exactness = clamp(Math.max(Number(copy.exactness) || 0, copy.areaConfidence), 0, 1);
        copy.hitKind = copy.areaConfidence >= 0.8 ? 'fill' : (copy.hitKind || 'bounds');
        return copy;
      }

      function collectTextAutoSelectCandidatesInSelection(selection) {
        if (!selection || !typeTool || !Array.isArray(typeTool.layers) || !typeTool.layers.length) return [];
        const out = [];
        for (let i = 0; i < typeTool.layers.length; i += 1) {
          const layer = typeTool.layers[i];
          if (!layer || layer.visible === false) continue;
          const boundsImage = typeof typeTool.getLayerBoundsImage === 'function' ? typeTool.getLayerBoundsImage(layer) : null;
          const boundsCanvas = imageRectToCanvasRect(boundsImage);
          if (!boundsCanvas) continue;
          const candidate = enrichCandidateForSelectionArea({
            id: layer.id,
            kind: 'text',
            family: 'text',
            label: (layer.name ? String(layer.name) : 'Text layer'),
            zIndex: 300 + i,
            exactness: 0.72,
            hitKind: 'bounds',
            boundsCanvas: boundsCanvas,
            selected: !!(typeTool.selectedId && typeTool.selectedId === layer.id)
          }, selection);
          if (candidate) out.push(candidate);
        }
        return out;
      }

      function collectRectangleAutoSelectCandidatesInSelection(selection) {
        if (!selection) return [];
        const shapes = getRectangleShapes();
        if (!shapes.length) return [];
        const out = [];
        for (let i = 0; i < shapes.length; i += 1) {
          const shape = shapes[i];
          if (!shape) continue;
          const m = getRectangleCanvasMetrics(shape);
          if (!m) continue;
          const candidate = enrichCandidateForSelectionArea({
            id: shape.id,
            kind: 'rectangle',
            family: 'shape',
            label: 'Rectangle',
            zIndex: 100 + i,
            exactness: 0.8,
            hitKind: 'bounds',
            boundsCanvas: { x: m.x, y: m.y, width: m.width, height: m.height },
            selected: !!(state.rectangleTool && state.rectangleTool.selectedId === shape.id),
            meta: { shapeId: shape.id }
          }, selection);
          if (candidate) out.push(candidate);
        }
        return out;
      }

      function collectPathAutoSelectCandidatesInSelection(selection) {
        if (!selection || !hasPenPath()) return [];
        const bounds = getPenPointBounds(state.pen.path);
        if (!bounds) return [];
        const candidate = enrichCandidateForSelectionArea({
          id: 'pen-path',
          kind: 'path',
          family: 'shape',
          label: 'Path',
          zIndex: 220,
          exactness: 0.78,
          hitKind: 'bounds-only',
          boundsCanvas: { x: bounds.x, y: bounds.y, width: bounds.width, height: bounds.height },
          selected: !!(pathSelectionTool && pathSelectionTool.selected)
        }, selection);
        return candidate ? [candidate] : [];
      }

      function collectAutoSelectCandidatesInSelection(selection) {
        if (!selection) return [];
        const candidates = [];
        candidates.push.apply(candidates, collectTextAutoSelectCandidatesInSelection(selection));
        candidates.push.apply(candidates, collectRectangleAutoSelectCandidatesInSelection(selection));
        candidates.push.apply(candidates, collectPathAutoSelectCandidatesInSelection(selection));
        return candidates;
      }

      function createSelectionFromAutoSelectCandidate(candidate, sourceSelection) {
        if (!candidate || !candidate.boundsCanvas) return null;
        const b = candidate.boundsCanvas;
        const pad = candidate.kind === 'path' ? 8 : 4;
        const x = (Number(b.x) || 0) - pad;
        const y = (Number(b.y) || 0) - pad;
        const w = Math.max(0, (Number(b.width) || 0) + (pad * 2));
        const h = Math.max(0, (Number(b.height) || 0) + (pad * 2));
        return {
          kind: 'marquee',
          x: x,
          y: y,
          width: w,
          height: h,
          autoSnap: true,
          sourceKind: sourceSelection && sourceSelection.kind ? sourceSelection.kind : 'lasso'
        };
      }

      function replaceCanvasSelectionFromAutoSelect(selection) {
        state.selection = selection || null;
        return true;
      }

      function commitAutoSelectedCandidate(candidate, context) {
        if (!candidate) return false;
        const source = (context && context.source) ? String(context.source) : 'auto-select';

        if (candidate.kind === 'text') {
          if (typeTool && typeof typeTool.selectLayerById === 'function') {
            if (pathSelectionTool && typeof pathSelectionTool.clearSelection === 'function') pathSelectionTool.clearSelection({ silent: true });
            clearRectangleSelection({ silent: true });
            return !!typeTool.selectLayerById(candidate.id, { silent: true, noRender: true, relist: false });
          }
          return false;
        }

        if (candidate.kind === 'rectangle') {
          if (pathSelectionTool && typeof pathSelectionTool.clearSelection === 'function') pathSelectionTool.clearSelection({ silent: true });
          setRectangleSelectedId(candidate.id, { silentRender: true });
          return true;
        }

        if (candidate.kind === 'path') {
          clearRectangleSelection({ silent: true });
          if (pathSelectionTool && typeof pathSelectionTool.selectPath === 'function') {
            return !!pathSelectionTool.selectPath({ silent: true, noRender: true });
          }
          return false;
        }

        return false;
      }

      function startRectangleMoveFromCanvas(canvasPoint, event, shapeId) {
        if (!canvasPoint || !shapeId || !state.image) return { handled: false };
        const shape = getRectangleShapeById(shapeId);
        if (!shape) return { handled: false };
        const mapped = getImagePointFromCanvasPoint(canvasPoint.x, canvasPoint.y, true);
        if (!mapped) return { handled: false };

        state.drag.rectShapeId = shape.id;
        state.drag.rectHandle = 'move';
        state.drag.rectMoved = false;
        state.drag.rectStartImagePoint = { x: mapped.x, y: mapped.y };
        state.drag.rectStartGeom = copyRectangleGeometry(shape);
        setRectangleSelectedId(shape.id, { silentRender: true });
        renderStage();
        return { handled: true, startDrag: true, dragMode: 'rectangle-move' };
      }

      function startPathMoveFromCanvas(canvasPoint, event) {
        if (!canvasPoint || !pathSelectionTool || typeof pathSelectionTool.handlePointerDown !== 'function') return { handled: false };
        const result = pathSelectionTool.handlePointerDown(canvasPoint, event) || { handled: false };
        if (result.handled === true && result.startDrag !== false) {
          return { handled: true, startDrag: true, dragMode: 'path-select' };
        }
        return result;
      }

      function startAutoSelectedCandidateDrag(candidate, canvasPoint, event) {
        if (!candidate || !canvasPoint) return { handled: false };
        if (candidate.kind === 'text' && typeTool && typeof typeTool.startMoveFromCanvas === 'function') {
          const textResult = typeTool.startMoveFromCanvas(canvasPoint, event) || { handled: false };
          if (textResult.handled === true && textResult.startDrag !== false) {
            return { handled: true, startDrag: true, dragMode: 'type' };
          }
          return textResult;
        }
        if (candidate.kind === 'rectangle') {
          return startRectangleMoveFromCanvas(canvasPoint, event, candidate.id);
        }
        if (candidate.kind === 'path') {
          return startPathMoveFromCanvas(canvasPoint, event);
        }
        return { handled: false };
      }

      function clearGradientPreview() {
        if (!state.gradient.preview) return false;
        state.gradient.preview = null;
        return true;
      }

      function setGradientPreviewFromPoints(startX, startY, endX, endY) {
        state.gradient.preview = {
          start: { x: startX, y: startY },
          end: { x: endX, y: endY }
        };
      }

      function isGradientPreviewUsable(preview) {
        if (!preview || !preview.start || !preview.end) return false;
        return distanceBetweenPoints(preview.start, preview.end) >= 2;
      }

      function createPenAnchor(x, y) {
        return {
          x: x,
          y: y,
          in: null,
          out: null
        };
      }

      function createEmptyPenPath() {
        return {
          points: [],
          closed: false
        };
      }

      function getPenPath() {
        if (!state.pen.path) state.pen.path = createEmptyPenPath();
        return state.pen.path;
      }

      function hasPenPath() {
        return !!(state.pen.path && Array.isArray(state.pen.path.points) && state.pen.path.points.length);
      }

      function isPenPathUsable(path) {
        const p = path || state.pen.path;
        return !!(p && Array.isArray(p.points) && p.points.length >= 2);
      }

      function clearPenSelection() {
        state.pen.selectedAnchorIndex = -1;
        state.pen.selectedHandle = null;
      }

      function clearPenPath(options) {
        const silent = !!(options && options.silent);
        const hadPath = hasPenPath();
        state.pen.path = null;
        state.pen.previewPoint = null;
        clearPenSelection();
        if (pathSelectionTool && typeof pathSelectionTool.clearSelection === 'function') {
          pathSelectionTool.clearSelection({ silent: true });
        }
        state.drag.penAnchorIndex = -1;
        state.drag.penHandleType = null;
        if (hadPath) {
          renderStage();
          if (!silent) setStatus('Pen path cleared.', 'info');
        }
      }

      function getPenAnchorAt(index) {
        const path = state.pen.path;
        if (!path || !Array.isArray(path.points)) return null;
        if (index < 0 || index >= path.points.length) return null;
        return path.points[index];
      }

      function getPenHandlePos(anchor, type) {
        if (!anchor) return null;
        return type === 'in' ? anchor.in : anchor.out;
      }

      function setPenHandlePos(anchor, type, point) {
        if (!anchor) return;
        if (!point) {
          if (type === 'in') anchor.in = null;
          else anchor.out = null;
          return;
        }
        const value = { x: point.x, y: point.y };
        if (type === 'in') anchor.in = value;
        else anchor.out = value;
      }

      function maybeRemoveTinyPenHandles(anchor) {
        if (!anchor) return;
        if (anchor.in && distanceBetweenPoints(anchor, anchor.in) < 1.2) anchor.in = null;
        if (anchor.out && distanceBetweenPoints(anchor, anchor.out) < 1.2) anchor.out = null;
      }

      function buildPenCanvasPath(path, context) {
        const p = path || state.pen.path;
        const targetCtx = context || ctx;
        if (!p || !Array.isArray(p.points) || p.points.length === 0 || !targetCtx) return false;

        const points = p.points;
        targetCtx.beginPath();
        targetCtx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i += 1) {
          const prev = points[i - 1];
          const curr = points[i];
          const c1 = prev.out || { x: prev.x, y: prev.y };
          const c2 = curr.in || { x: curr.x, y: curr.y };
          targetCtx.bezierCurveTo(c1.x, c1.y, c2.x, c2.y, curr.x, curr.y);
        }
        if (p.closed && points.length >= 2) {
          const last = points[points.length - 1];
          const first = points[0];
          const c1 = last.out || { x: last.x, y: last.y };
          const c2 = first.in || { x: first.x, y: first.y };
          targetCtx.bezierCurveTo(c1.x, c1.y, c2.x, c2.y, first.x, first.y);
          targetCtx.closePath();
        }
        return true;
      }

      function getPenPointBounds(path) {
        const p = path || state.pen.path;
        if (!p || !Array.isArray(p.points) || p.points.length === 0) return null;
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        for (const anchor of p.points) {
          const pts = [anchor, anchor.in, anchor.out];
          for (const pt of pts) {
            if (!pt) continue;
            if (pt.x < minX) minX = pt.x;
            if (pt.y < minY) minY = pt.y;
            if (pt.x > maxX) maxX = pt.x;
            if (pt.y > maxY) maxY = pt.y;
          }
        }
        return { x: minX, y: minY, width: Math.max(0, maxX - minX), height: Math.max(0, maxY - minY) };
      }

      function isNearPenPathStart(point, radius) {
        const path = state.pen.path;
        if (!point || !path || !Array.isArray(path.points) || path.points.length < 2 || path.closed) return false;
        const first = path.points[0];
        if (!first) return false;
        return distanceBetweenPoints(point, first) <= (radius || 10);
      }

      function getPenHitTarget(point) {
        const path = state.pen.path;
        if (!point || !path || !Array.isArray(path.points) || !path.points.length) return null;
        const anchorRadius = 8;
        const handleRadius = 7;
        for (let i = path.points.length - 1; i >= 0; i -= 1) {
          const a = path.points[i];
          if (a.out && distanceBetweenPoints(point, a.out) <= handleRadius) {
            return { kind: 'handle', anchorIndex: i, handleType: 'out' };
          }
          if (a.in && distanceBetweenPoints(point, a.in) <= handleRadius) {
            return { kind: 'handle', anchorIndex: i, handleType: 'in' };
          }
        }
        for (let i = path.points.length - 1; i >= 0; i -= 1) {
          const a = path.points[i];
          if (distanceBetweenPoints(point, a) <= anchorRadius) {
            return { kind: 'anchor', anchorIndex: i };
          }
        }
        return null;
      }

      function movePenAnchor(anchorIndex, dx, dy) {
        const anchor = getPenAnchorAt(anchorIndex);
        if (!anchor) return false;
        anchor.x += dx;
        anchor.y += dy;
        if (anchor.in) {
          anchor.in.x += dx;
          anchor.in.y += dy;
        }
        if (anchor.out) {
          anchor.out.x += dx;
          anchor.out.y += dy;
        }
        return true;
      }

      function moveEntirePenPath(dx, dy) {
        const path = state.pen.path;
        if (!path || !Array.isArray(path.points) || !path.points.length) return false;
        const shiftX = Number(dx) || 0;
        const shiftY = Number(dy) || 0;
        if (Math.abs(shiftX) + Math.abs(shiftY) < 0.0001) return false;
        for (const anchor of path.points) {
          if (!anchor) continue;
          anchor.x += shiftX;
          anchor.y += shiftY;
          if (anchor.in) {
            anchor.in.x += shiftX;
            anchor.in.y += shiftY;
          }
          if (anchor.out) {
            anchor.out.x += shiftX;
            anchor.out.y += shiftY;
          }
        }
        return true;
      }

      function hitTestPenPathAtCanvasPoint(point, tolerance) {
        const path = state.pen.path;
        if (!point || !path || !Array.isArray(path.points) || !path.points.length || !ctx) return { hit: false };

        const bounds = getPenPointBounds(path);
        const pad = Math.max(4, Number(tolerance) || 10);
        if (bounds) {
          if (point.x < (bounds.x - pad) || point.x > (bounds.x + bounds.width + pad) || point.y < (bounds.y - pad) || point.y > (bounds.y + bounds.height + pad)) {
            return { hit: false };
          }
        }

        if (!isPenPathUsable(path)) {
          return { hit: !!bounds, stroke: false, fill: false, boundsOnly: true };
        }

        let strokeHit = false;
        let fillHit = false;
        ctx.save();
        try {
          if (!buildPenCanvasPath(path, ctx)) return { hit: false };
          ctx.lineWidth = Math.max(2, (Number(tolerance) || 10) * 2);
          ctx.lineJoin = 'round';
          ctx.lineCap = 'round';
          if (typeof ctx.isPointInStroke === 'function') {
            strokeHit = !!ctx.isPointInStroke(point.x, point.y);
          }
          if (!strokeHit && path.closed && path.points.length >= 3 && typeof ctx.isPointInPath === 'function') {
            fillHit = !!ctx.isPointInPath(point.x, point.y);
          }
        } finally {
          ctx.restore();
        }
        return { hit: !!(strokeHit || fillHit), stroke: strokeHit, fill: fillHit };
      }

      function setPenHandle(anchorIndex, handleType, point, mirrorOpposite) {
        const anchor = getPenAnchorAt(anchorIndex);
        if (!anchor) return false;
        setPenHandlePos(anchor, handleType, point);
        if (mirrorOpposite) {
          const opposite = handleType === 'in' ? 'out' : 'in';
          const dx = point.x - anchor.x;
          const dy = point.y - anchor.y;
          setPenHandlePos(anchor, opposite, { x: anchor.x - dx, y: anchor.y - dy });
        }
        maybeRemoveTinyPenHandles(anchor);
        return true;
      }

      function createOrResetPenPathIfClosed() {
        if (state.pen.path && state.pen.path.closed) {
          clearPenPath({ silent: true });
        }
        return getPenPath();
      }

      function addPenAnchor(point) {
        const path = createOrResetPenPathIfClosed();
        const anchor = createPenAnchor(point.x, point.y);
        path.points.push(anchor);
        path.closed = false;
        state.pen.selectedAnchorIndex = path.points.length - 1;
        state.pen.selectedHandle = null;
        return path.points.length - 1;
      }

      function closePenPath() {
        const path = state.pen.path;
        if (!isPenPathUsable(path) || path.closed) return false;
        path.closed = true;
        state.pen.selectedAnchorIndex = 0;
        state.pen.selectedHandle = null;
        state.pen.previewPoint = null;
        return true;
      }

      function removeSelectedOrLastPenAnchor() {
        const path = state.pen.path;
        if (!path || !Array.isArray(path.points) || !path.points.length) return false;
        let index = state.pen.selectedAnchorIndex;
        if (!(index >= 0 && index < path.points.length)) index = path.points.length - 1;
        path.points.splice(index, 1);
        path.closed = false;
        state.pen.selectedHandle = null;
        if (!path.points.length) {
          clearPenPath({ silent: true });
          return true;
        }
        state.pen.selectedAnchorIndex = Math.max(0, Math.min(index, path.points.length - 1));
        return true;
      }

      function mirrorPenHandlesForNewAnchor(anchorIndex, point) {
        const anchor = getPenAnchorAt(anchorIndex);
        if (!anchor || !point) return;
        const dx = point.x - anchor.x;
        const dy = point.y - anchor.y;
        if (Math.abs(dx) + Math.abs(dy) < 1) {
          anchor.in = null;
          anchor.out = null;
          return;
        }
        anchor.out = { x: anchor.x + dx, y: anchor.y + dy };
        anchor.in = { x: anchor.x - dx, y: anchor.y - dy };
      }

      function renderPenOverlay() {
        const path = state.pen.path;
        if (!path || !Array.isArray(path.points) || !path.points.length) return;

        ctx.save();

        // Handle lines
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.strokeStyle = 'rgba(132, 181, 255, 0.55)';
        for (let i = 0; i < path.points.length; i += 1) {
          const a = path.points[i];
          if (a.in) {
            ctx.beginPath();
            ctx.moveTo(a.x, a.y);
            ctx.lineTo(a.in.x, a.in.y);
            ctx.stroke();
          }
          if (a.out) {
            ctx.beginPath();
            ctx.moveTo(a.x, a.y);
            ctx.lineTo(a.out.x, a.out.y);
            ctx.stroke();
          }
        }
        ctx.setLineDash([]);

        if (buildPenCanvasPath(path, ctx)) {
          if (path.closed && path.points.length >= 3) {
            ctx.fillStyle = 'rgba(132, 181, 255,' + clamp(Number(state.pen.fillOpacity || 0.12), 0, 1) + ')';
            ctx.fill();
          }
          ctx.lineWidth = Math.max(1, Number(state.pen.strokeWidthCanvasPx || 2.8));
          ctx.strokeStyle = 'rgba(132, 181, 255,' + clamp(Number(state.pen.strokeOpacity || 0.95), 0, 1) + ')';
          ctx.stroke();
        }

        // Preview line to next anchor
        if (!path.closed && state.activeTool === 'pen' && state.pen.previewPoint && path.points.length >= 1) {
          const last = path.points[path.points.length - 1];
          ctx.setLineDash([6, 5]);
          ctx.lineWidth = 1.5;
          ctx.strokeStyle = 'rgba(255,255,255,0.6)';
          ctx.beginPath();
          ctx.moveTo(last.x, last.y);
          ctx.lineTo(state.pen.previewPoint.x, state.pen.previewPoint.y);
          ctx.stroke();
          ctx.setLineDash([]);

          if (isNearPenPathStart(state.pen.previewPoint, 10) && path.points.length >= 2) {
            const first = path.points[0];
            ctx.strokeStyle = 'rgba(119, 255, 179, 0.9)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(first.x, first.y, 8, 0, Math.PI * 2);
            ctx.stroke();
          }
        }

        // Handles/anchors
        for (let i = 0; i < path.points.length; i += 1) {
          const a = path.points[i];
          const isSelectedAnchor = i === state.pen.selectedAnchorIndex;
          const selectedHandle = state.pen.selectedHandle;

          if (a.in) {
            const active = !!(selectedHandle && selectedHandle.anchorIndex === i && selectedHandle.handleType === 'in');
            ctx.fillStyle = active ? '#7fffd4' : '#dfe7ff';
            ctx.strokeStyle = 'rgba(9, 12, 18, 0.95)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.rect(a.in.x - 3.5, a.in.y - 3.5, 7, 7);
            ctx.fill();
            ctx.stroke();
          }
          if (a.out) {
            const active = !!(selectedHandle && selectedHandle.anchorIndex === i && selectedHandle.handleType === 'out');
            ctx.fillStyle = active ? '#7fffd4' : '#dfe7ff';
            ctx.strokeStyle = 'rgba(9, 12, 18, 0.95)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.rect(a.out.x - 3.5, a.out.y - 3.5, 7, 7);
            ctx.fill();
            ctx.stroke();
          }

          ctx.fillStyle = isSelectedAnchor ? '#8cb8ff' : '#ffffff';
          ctx.strokeStyle = i === 0 && !path.closed ? 'rgba(83, 255, 158, 0.85)' : 'rgba(9, 12, 18, 0.95)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(a.x, a.y, isSelectedAnchor ? 5.2 : 4.4, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
        }

        ctx.restore();
      }

      function getGradientPresetById(id) {
        return GRADIENT_PRESETS.find(function (preset) { return preset.id === id; }) || null;
      }

      function markGradientPresetCustom() {
        if (state.gradient.presetId !== 'custom') {
          state.gradient.presetId = 'custom';
          updateGradientPresetButtonsUi();
        }
      }

      function getGradientPresetCss(preset) {
        const stops = Array.isArray(preset && preset.stops) ? preset.stops.filter(Boolean) : [];
        if (!stops.length) return '#2a2d38';
        if (stops.length === 1) return stops[0];
        return 'linear-gradient(90deg, ' + stops.join(', ') + ')';
      }

      function updateGradientPresetButtonsUi() {
        if (!els.gradientPresets) return;
        const buttons = els.gradientPresets.querySelectorAll('.gradient-preset-btn');
        for (const btn of buttons) {
          const id = btn.getAttribute('data-preset-id') || '';
          btn.classList.toggle('active', id === state.gradient.presetId);
        }
      }

      function updateGradientControlsUi() {
        if (els.gradientTypeSelect) els.gradientTypeSelect.value = state.gradient.type || 'linear';
        if (els.gradientBlendSelect) els.gradientBlendSelect.value = state.gradient.blendMode || 'source-over';
        if (els.gradientFadeEndCheckbox) els.gradientFadeEndCheckbox.checked = !!state.gradient.fadeEnd;
        if (els.gradientMidToggleCheckbox) els.gradientMidToggleCheckbox.checked = !!state.gradient.useMidStop;
        if (els.gradientStartColorInput) els.gradientStartColorInput.value = String(state.gradient.startColor || '#ffffff');
        if (els.gradientMidColorInput) els.gradientMidColorInput.value = String(state.gradient.midColor || '#ffd166');
        if (els.gradientEndColorInput) els.gradientEndColorInput.value = String(state.gradient.endColor || '#000000');
        if (els.gradientMidColorWrap) els.gradientMidColorWrap.hidden = !state.gradient.useMidStop;
        if (els.gradientOpacityRange) {
          const v = clamp(Math.round((Number(state.gradient.opacity) || 0) * 100), 5, 100);
          els.gradientOpacityRange.value = String(v);
          if (els.gradientOpacityValue) els.gradientOpacityValue.textContent = v + '%';
        } else if (els.gradientOpacityValue) {
          els.gradientOpacityValue.textContent = Math.round((Number(state.gradient.opacity) || 0) * 100) + '%';
        }
        updateGradientPresetButtonsUi();
      }

      function updateGradientControlsVisibility() {
        const show = state.activeTool === 'gradient';
        if (els.gradientControls) els.gradientControls.hidden = !show;
        if (els.gradientToolbarSep) els.gradientToolbarSep.hidden = !show;
      }

      function applyGradientPresetToState(presetId) {
        const preset = getGradientPresetById(presetId);
        if (!preset) return false;
        const stops = Array.isArray(preset.stops) ? preset.stops : [];
        if (stops[0]) state.gradient.startColor = stops[0];
        if (stops[1]) {
          if (preset.useMidStop && stops[2]) {
            state.gradient.midColor = stops[1];
            state.gradient.endColor = stops[2];
          } else {
            state.gradient.endColor = stops[1];
          }
        }
        if (stops[2] && !preset.useMidStop) {
          state.gradient.endColor = stops[2];
        }
        state.gradient.useMidStop = !!preset.useMidStop;
        state.gradient.fadeEnd = !!preset.fadeEnd;
        state.gradient.opacity = clamp(Number(preset.opacity), 0.05, 1) || state.gradient.opacity;
        if (preset.blendMode) state.gradient.blendMode = preset.blendMode;
        if (preset.type) state.gradient.type = preset.type;
        state.gradient.presetId = preset.id;
        updateGradientControlsUi();
        if (state.activeTool === 'gradient' && isGradientPreviewUsable(state.gradient.preview)) renderStage();
        return true;
      }

      function renderGradientPresetButtons() {
        if (!els.gradientPresets) return;
        els.gradientPresets.innerHTML = '';
        for (const preset of GRADIENT_PRESETS) {
          if (preset.hidden) continue;
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'gradient-preset-btn';
          btn.setAttribute('role', 'listitem');
          btn.setAttribute('title', preset.label);
          btn.setAttribute('aria-label', preset.label + ' gradient preset');
          btn.setAttribute('data-preset-id', preset.id);
          btn.style.background = getGradientPresetCss(preset);
          btn.addEventListener('click', function () {
            applyGradientPresetToState(preset.id);
            setStatus('Gradient preset: ' + preset.label, 'success');
          });
          els.gradientPresets.appendChild(btn);
        }
        updateGradientPresetButtonsUi();
      }

      function createLassoSelectionFromPoints(points, closed) {
        const pts = Array.isArray(points) ? points.filter(Boolean).map(clonePoint) : [];
        if (pts.length === 0) return null;

        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        for (const p of pts) {
          if (p.x < minX) minX = p.x;
          if (p.y < minY) minY = p.y;
          if (p.x > maxX) maxX = p.x;
          if (p.y > maxY) maxY = p.y;
        }

        return {
          kind: 'lasso',
          points: pts,
          closed: closed !== false,
          x: minX,
          y: minY,
          width: Math.max(0, maxX - minX),
          height: Math.max(0, maxY - minY)
        };
      }

      function isSelectionUsable(sel) {
        if (!sel) return false;
        if (sel.kind === 'lasso') {
          return Array.isArray(sel.points) && sel.points.length >= 3 && sel.width >= 2 && sel.height >= 2;
        }
        return sel.width >= 2 && sel.height >= 2;
      }

      function isCropBoxUsable(box) {
        return !!(box && box.width >= 2 && box.height >= 2);
      }

      function drawSelectionOutlinePath(points, closed) {
        if (!Array.isArray(points) || points.length === 0) return;
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i += 1) {
          ctx.lineTo(points[i].x, points[i].y);
        }
        if (closed) ctx.closePath();
      }

      function renderSelectionOverlay() {
        const s = state.selection;
        if (!s) return;

        if (s.kind === 'lasso') {
          if (!Array.isArray(s.points) || s.points.length < 2) return;
          ctx.save();

          if (s.closed && isSelectionUsable(s)) {
            drawSelectionOutlinePath(s.points, true);
            ctx.fillStyle = 'rgba(103, 151, 255, 0.08)';
            ctx.fill();
          }

          ctx.setLineDash([6, 4]);
          ctx.lineWidth = 1;
          drawSelectionOutlinePath(s.points, !!s.closed);
          ctx.strokeStyle = 'rgba(255,255,255,0.96)';
          ctx.stroke();
          ctx.lineDashOffset = 5;
          drawSelectionOutlinePath(s.points, !!s.closed);
          ctx.strokeStyle = 'rgba(0,0,0,0.95)';
          ctx.stroke();

          ctx.setLineDash([]);
          for (const p of s.points) {
            ctx.fillStyle = 'rgba(255,255,255,0.95)';
            ctx.fillRect(Math.round(p.x - 1), Math.round(p.y - 1), 2, 2);
          }

          if (s.closed && isSelectionUsable(s)) {
            const handles = [
              [s.x, s.y],
              [s.x + s.width / 2, s.y],
              [s.x + s.width, s.y],
              [s.x, s.y + s.height / 2],
              [s.x + s.width, s.y + s.height / 2],
              [s.x, s.y + s.height],
              [s.x + s.width / 2, s.y + s.height],
              [s.x + s.width, s.y + s.height]
            ];
            for (const h of handles) {
              ctx.fillStyle = '#ffffff';
              ctx.fillRect(Math.round(h[0] - 3), Math.round(h[1] - 3), 6, 6);
              ctx.strokeStyle = '#161616';
              ctx.strokeRect(Math.round(h[0] - 3) + 0.5, Math.round(h[1] - 3) + 0.5, 5, 5);
            }
          }

          ctx.restore();
          return;
        }

        if (!(s.width > 0.5 && s.height > 0.5)) return;

        ctx.save();
        ctx.fillStyle = 'rgba(103, 151, 255, 0.08)';
        ctx.fillRect(s.x, s.y, s.width, s.height);

        ctx.setLineDash([6, 4]);
        ctx.lineWidth = 1;
        ctx.strokeStyle = 'rgba(255,255,255,0.96)';
        ctx.strokeRect(s.x + 0.5, s.y + 0.5, Math.max(0, s.width - 1), Math.max(0, s.height - 1));
        ctx.lineDashOffset = 5;
        ctx.strokeStyle = 'rgba(0,0,0,0.95)';
        ctx.strokeRect(s.x + 0.5, s.y + 0.5, Math.max(0, s.width - 1), Math.max(0, s.height - 1));

        const handles = [
          [s.x, s.y],
          [s.x + s.width / 2, s.y],
          [s.x + s.width, s.y],
          [s.x, s.y + s.height / 2],
          [s.x + s.width, s.y + s.height / 2],
          [s.x, s.y + s.height],
          [s.x + s.width / 2, s.y + s.height],
          [s.x + s.width, s.y + s.height]
        ];
        ctx.setLineDash([]);
        for (const h of handles) {
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(Math.round(h[0] - 3), Math.round(h[1] - 3), 6, 6);
          ctx.strokeStyle = '#161616';
          ctx.strokeRect(Math.round(h[0] - 3) + 0.5, Math.round(h[1] - 3) + 0.5, 5, 5);
        }
        ctx.restore();
      }

      function renderCropOverlay() {
        const c = state.cropBox;
        if (!c || !state.image) return;
        if (!(c.width > 0.5 && c.height > 0.5)) return;

        const canvasW = els.canvas.width;
        const canvasH = els.canvas.height;
        const x1 = clamp(c.x, 0, canvasW);
        const y1 = clamp(c.y, 0, canvasH);
        const x2 = clamp(c.x + c.width, 0, canvasW);
        const y2 = clamp(c.y + c.height, 0, canvasH);
        const w = Math.max(0, x2 - x1);
        const h = Math.max(0, y2 - y1);

        ctx.save();
        ctx.fillStyle = 'rgba(0, 0, 0, 0.52)';
        if (y1 > 0) ctx.fillRect(0, 0, canvasW, y1);
        if (y2 < canvasH) ctx.fillRect(0, y2, canvasW, canvasH - y2);
        if (x1 > 0 && h > 0) ctx.fillRect(0, y1, x1, h);
        if (x2 < canvasW && h > 0) ctx.fillRect(x2, y1, canvasW - x2, h);

        if (w > 0 && h > 0) {
          ctx.strokeStyle = 'rgba(255,255,255,0.95)';
          ctx.lineWidth = 1;
          ctx.strokeRect(x1 + 0.5, y1 + 0.5, Math.max(0, w - 1), Math.max(0, h - 1));

          ctx.strokeStyle = 'rgba(255,255,255,0.12)';
          ctx.beginPath();
          ctx.moveTo(x1 + (w / 3), y1);
          ctx.lineTo(x1 + (w / 3), y2);
          ctx.moveTo(x1 + ((w * 2) / 3), y1);
          ctx.lineTo(x1 + ((w * 2) / 3), y2);
          ctx.moveTo(x1, y1 + (h / 3));
          ctx.lineTo(x2, y1 + (h / 3));
          ctx.moveTo(x1, y1 + ((h * 2) / 3));
          ctx.lineTo(x2, y1 + ((h * 2) / 3));
          ctx.stroke();

          const handles = [
            [x1, y1],
            [x1 + w / 2, y1],
            [x2, y1],
            [x1, y1 + h / 2],
            [x2, y1 + h / 2],
            [x1, y2],
            [x1 + w / 2, y2],
            [x2, y2]
          ];
          for (const handle of handles) {
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(Math.round(handle[0] - 3), Math.round(handle[1] - 3), 6, 6);
            ctx.strokeStyle = '#131313';
            ctx.strokeRect(Math.round(handle[0] - 3) + 0.5, Math.round(handle[1] - 3) + 0.5, 5, 5);
          }
        }

        ctx.restore();
      }

      function updateToolButtonsUi() {
        if (!els.leftToolButtons || !els.leftToolButtons.length) return;
        for (const btn of els.leftToolButtons) {
          const tool = btn.getAttribute('data-tool');
          const isActive = !!tool && tool === state.activeTool;
          btn.classList.toggle('active', isActive);
        }
      }

      function updateCanvasToolClass() {
        if (!els.canvas) return;
        els.canvas.classList.toggle('tool-marquee', state.activeTool === 'marquee');
        els.canvas.classList.toggle('tool-lasso', state.activeTool === 'lasso');
        els.canvas.classList.toggle('tool-crop', state.activeTool === 'crop');
        els.canvas.classList.toggle('tool-heal', state.activeTool === 'heal');
        els.canvas.classList.toggle('tool-brush', state.activeTool === 'brush');
        els.canvas.classList.toggle('tool-eraser', state.activeTool === 'eraser');
        els.canvas.classList.toggle('tool-gradient', state.activeTool === 'gradient');
        els.canvas.classList.toggle('tool-rectangle', state.activeTool === 'rectangle');
        els.canvas.classList.toggle('tool-blur', state.activeTool === 'blur');
        els.canvas.classList.toggle('tool-dodge', state.activeTool === 'dodge');
        els.canvas.classList.toggle('tool-pen', state.activeTool === 'pen');
        els.canvas.classList.toggle('tool-path-select', state.activeTool === 'path-select');
        els.canvas.classList.toggle('tool-hand', state.activeTool === 'hand');
        els.canvas.classList.toggle('tool-zoom', state.activeTool === 'zoom');
        els.canvas.classList.toggle('tool-type', state.activeTool === 'type');
        els.canvas.classList.toggle('tool-move', state.activeTool === 'move');
      }

      function clearSelection(options) {
        const silent = !!(options && options.silent);
        if (!state.selection) return;
        state.selection = null;
        renderStage();
        if (!silent) setStatus('Selection cleared.', 'info');
      }

      function clearCropBox(options) {
        const silent = !!(options && options.silent);
        if (!state.cropBox) return;
        state.cropBox = null;
        renderStage();
        if (!silent) setStatus('Crop box cleared.', 'info');
      }

      function setActiveTool(tool) {
        if (tool !== 'move' && tool !== 'marquee' && tool !== 'lasso' && tool !== 'crop' && tool !== 'heal' && tool !== 'brush' && tool !== 'eraser' && tool !== 'gradient' && tool !== 'rectangle' && tool !== 'blur' && tool !== 'dodge' && tool !== 'pen' && tool !== 'path-select' && tool !== 'hand' && tool !== 'zoom' && tool !== 'type') return;
        if (state.activeTool === tool) return;
        if (tool !== 'gradient') state.gradient.preview = null;
        if (tool !== 'pen' && tool !== 'path-select') state.pen.previewPoint = null;
        state.activeTool = tool;
        updateToolButtonsUi();
        updateCanvasToolClass();
        updateGradientControlsVisibility();
        updateGradientControlsUi();
        updateRectangleControlsVisibility();
        updateRectangleControlsUi();
        if (pathSelectionTool && typeof pathSelectionTool.setToolActive === 'function') {
          pathSelectionTool.setToolActive(tool === 'path-select');
        }
        if (handTool && typeof handTool.setToolActive === 'function') {
          handTool.setToolActive(tool === 'hand');
        }
        if (zoomTool && typeof zoomTool.setToolActive === 'function') {
          zoomTool.setToolActive(tool === 'zoom');
        }
        if (typeTool && typeof typeTool.setToolActive === 'function') {
          typeTool.setToolActive(tool === 'type');
        }
        renderStage();
        if (tool === 'marquee') {
          setStatus('Marquee Tool active. Drag on the workspace to create a selection.', 'success');
        } else if (tool === 'lasso') {
          setStatus('Lasso Tool active. Drag to draw a freehand selection. With Auto-Select on, it can snap to the best object in the area.', 'success');
        } else if (tool === 'crop') {
          setStatus('Crop Tool active. Drag to create a crop box, then press Enter to apply.', 'success');
        } else if (tool === 'heal') {
          setStatus('Spot Healing Brush active. Click or drag to auto-heal with nearby texture sampling.', 'success');
        } else if (tool === 'brush') {
          setStatus('Brush Tool active. Click or drag on the image to paint.', 'success');
        } else if (tool === 'eraser') {
          setStatus('Eraser Tool active. Click or drag on the image to erase.', 'success');
        } else if (tool === 'gradient') {
          setStatus('Gradient Tool active. Use toolbar presets/colors, then drag on the image to apply.', 'success');
        } else if (tool === 'rectangle') {
          setStatus('Rectangle Tool active. Drag to create shapes | drag handles to resize | use toolbar for fill/stroke/radius/blend.', 'success');
        } else if (tool === 'blur') {
          setStatus('Blur Tool active. Click or drag on the image to blur areas.', 'success');
        } else if (tool === 'dodge') {
          setStatus('Dodge Tool active. Click or drag to lighten details and highlights.', 'success');
        } else if (tool === 'pen') {
          setStatus('Pen Tool active. Click anchors, drag for bezier handles, Shift snap, Alt break handles, Enter apply.', 'success');
        } else if (tool === 'path-select') {
          setStatus('Path Selection Tool active. Click a pen path to select it, then drag to move it.', 'success');
        } else if (tool === 'hand') {
          setStatus('Hand Tool active. Drag the image to pan around the workspace.', 'success');
        } else if (tool === 'zoom') {
          setStatus('Zoom Tool active. Click to zoom in, Alt/Shift-click to zoom out, drag a box to zoom to area.', 'success');
        } else if (tool === 'type') {
          setStatus('Type Tool active. Click image to create/select text. Use the right panel for advanced text styling.', 'success');
        } else {
          const autoSuffix = autoSelectController && typeof autoSelectController.getMoveHintSuffix === 'function'
            ? (' ' + autoSelectController.getMoveHintSuffix() + '.')
            : '';
          setStatus('Move Tool active. Drag the image to move it.' + autoSuffix, 'success');
        }
      }

      function setSelectionFromPoints(startX, startY, currentX, currentY, constrainSquare) {
        let x2 = currentX;
        let y2 = currentY;
        if (constrainSquare) {
          const dx = currentX - startX;
          const dy = currentY - startY;
          const side = Math.max(Math.abs(dx), Math.abs(dy));
          x2 = startX + (dx < 0 ? -side : side);
          y2 = startY + (dy < 0 ? -side : side);
        }
        state.selection = normalizeRect(startX, startY, x2, y2);
      }

      function resizeCanvasToStage() {
        if (!els.canvas || !els.canvasArea) return false;

        const rect = els.canvasArea.getBoundingClientRect();
        const width = Math.max(320, Math.floor(rect.width || 0));
        const height = Math.max(220, Math.floor(rect.height || 0));
        if (!width || !height) return false;

        if (els.canvas.width === width && els.canvas.height === height) return false;

        const wasCenteredFit =
          !!state.image &&
          Math.abs(state.view.offsetX) < 0.5 &&
          Math.abs(state.view.offsetY) < 0.5 &&
          Math.abs(state.view.scale - state.view.fitScale) < 0.0001;

        els.canvas.width = width;
        els.canvas.height = height;

        if (state.image && wasCenteredFit) fitImageToCanvas();
        else renderStage();

        return true;
      }

      function setCanvasHasImageClass() {
        if (!els.canvas) return;
        els.canvas.classList.toggle('no-image', !state.image);
        updateCanvasToolClass();
      }

      function updateZoomReadout() {
        if (!els.zoomReadout) return;
        const percent = Math.round((state.view.scale || 1) * 100);
        els.zoomReadout.textContent = percent + '%';
      }

      function setStageHint(text) {
        if (els.stageHint) els.stageHint.textContent = text;
      }

      function updateStageHintForCurrentTool(hasImage) {
        if (state.activeTool === 'marquee') {
          setStageHint('Marquee: drag to select | Shift: square | Esc: clear | Ctrl+Wheel: zoom');
          return;
        }
        if (state.activeTool === 'lasso') {
          setStageHint('Lasso: drag freehand selection | Auto-Select can snap to object | Esc clear | L lasso | V move');
          return;
        }
        if (state.activeTool === 'crop') {
          if (!hasImage) {
            setStageHint('Crop: import an image first | Ctrl+O import | C crop');
            return;
          }
          setStageHint('Crop: drag crop box | Enter apply | Esc clear | Shift square');
          return;
        }
        if (state.activeTool === 'heal') {
          if (!hasImage) {
            setStageHint('Spot Heal: import an image first | Ctrl+O import | J heal brush');
            return;
          }
          setStageHint('Spot Heal: auto texture heal on drag | J heal | R blur | V move | Ctrl+Wheel zoom');
          return;
        }
        if (state.activeTool === 'brush') {
          if (!hasImage) {
            setStageHint('Brush: import an image first | Ctrl+O import | B brush | E eraser');
            return;
          }
          setStageHint('Brush: click/drag to paint | E eraser | J heal | V move');
          return;
        }
        if (state.activeTool === 'eraser') {
          if (!hasImage) {
            setStageHint('Eraser: import an image first | Ctrl+O import | E eraser');
            return;
          }
          setStageHint('Eraser: click/drag to erase | B brush | E eraser | V move');
          return;
        }
        if (state.activeTool === 'gradient') {
          if (!hasImage) {
            setStageHint('Gradient: import an image first | Ctrl+O import | G gradient');
            return;
          }
          setStageHint('Gradient: toolbar presets/colors/type/blend | Drag to apply | G gradient | V move');
          return;
        }
        if (state.activeTool === 'rectangle') {
          if (!hasImage) {
            setStageHint('Rectangle: import an image first | Ctrl+O import | U rectangle');
            return;
          }
          setStageHint('Rectangle: drag create | Shift square | drag handles resize | toolbar fill/stroke/radius/blend | U rectangle');
          return;
        }
        if (state.activeTool === 'blur') {
          if (!hasImage) {
            setStageHint('Blur: import an image first | Ctrl+O import | R blur');
            return;
          }
          setStageHint('Blur: click/drag to blur | R blur | J heal | B brush | V move');
          return;
        }
        if (state.activeTool === 'dodge') {
          if (!hasImage) {
            setStageHint('Dodge: import an image first | Ctrl+O import | O dodge');
            return;
          }
          setStageHint('Dodge: click/drag to lighten | O dodge | R blur | B brush | V move');
          return;
        }
        if (state.activeTool === 'pen') {
          if (!hasImage) {
            setStageHint('Pen: import an image first | Ctrl+O import | P pen');
            return;
          }
          setStageHint('Pen: click anchors/drag bezier | Shift snap | Alt split handles | Enter apply | Del remove | Esc clear');
          return;
        }
        if (state.activeTool === 'path-select') {
          if (!hasImage) {
            setStageHint('Path Selection: import an image first | Ctrl+O import | A path select');
            return;
          }
          setStageHint('Path Selection: click pen path to select | Drag move path | A path select | P pen | Enter apply');
          return;
        }
        if (state.activeTool === 'hand') {
          if (!hasImage) {
            setStageHint('Hand: import an image first | Ctrl+O import | H hand');
            return;
          }
          setStageHint('Hand: drag to pan | Wheel pan | Ctrl+Wheel zoom | H hand | Z zoom');
          return;
        }
        if (state.activeTool === 'zoom') {
          if (!hasImage) {
            setStageHint('Zoom: import an image first | Ctrl+O import | Z zoom');
            return;
          }
          setStageHint('Zoom: click in | Alt/Shift click out | Drag box zoom | Z zoom | H hand');
          return;
        }
        if (state.activeTool === 'type') {
          if (!hasImage) {
            setStageHint('Type: import an image first | Ctrl+O import | T type');
            return;
          }
          setStageHint('Type: click to create/select text | Drag to move | Right sidebar: font/effects | T type');
          return;
        }
        if (hasImage) {
          const autoSuffix = autoSelectController && typeof autoSelectController.getMoveHintSuffix === 'function'
            ? (' | ' + autoSelectController.getMoveHintSuffix())
            : '';
          setStageHint('Move: drag image | click object to auto-select + drag | Wheel pan | Ctrl+Wheel zoom | Double-click fit' + autoSuffix);
          return;
        }
        setStageHint('Import an image first | Ctrl+O import | M marquee | L lasso | C crop | J heal | B brush | E eraser | G gradient | U rectangle | R blur | O dodge | P pen | A path select | H hand | Z zoom | T type');
      }

      function getCanvasCenter() {
        return {
          x: els.canvas.width / 2,
          y: els.canvas.height / 2
        };
      }

      function getImageDrawRect() {
        if (!state.image) return null;
        const center = getCanvasCenter();
        const w = Math.max(1, state.image.width * state.view.scale);
        const h = Math.max(1, state.image.height * state.view.scale);
        return {
          x: center.x - (w / 2) + state.view.offsetX,
          y: center.y - (h / 2) + state.view.offsetY,
          width: w,
          height: h
        };
      }

      function drawStageBackground() {
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, els.canvas.width, els.canvas.height);

        const gradient = ctx.createLinearGradient(0, 0, 0, els.canvas.height);
        gradient.addColorStop(0, '#0b0c0f');
        gradient.addColorStop(1, '#08090b');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, els.canvas.width, els.canvas.height);

        const g1 = ctx.createRadialGradient(
          els.canvas.width * 0.22, els.canvas.height * 0.2, 0,
          els.canvas.width * 0.22, els.canvas.height * 0.2, els.canvas.width * 0.5
        );
        g1.addColorStop(0, 'rgba(100, 140, 255, 0.06)');
        g1.addColorStop(1, 'rgba(100, 140, 255, 0)');
        ctx.fillStyle = g1;
        ctx.fillRect(0, 0, els.canvas.width, els.canvas.height);

        const g2 = ctx.createRadialGradient(
          els.canvas.width * 0.82, els.canvas.height * 0.75, 0,
          els.canvas.width * 0.82, els.canvas.height * 0.75, els.canvas.width * 0.4
        );
        g2.addColorStop(0, 'rgba(255, 255, 255, 0.03)');
        g2.addColorStop(1, 'rgba(255, 255, 255, 0)');
        ctx.fillStyle = g2;
        ctx.fillRect(0, 0, els.canvas.width, els.canvas.height);

        ctx.strokeStyle = 'rgba(255,255,255,0.025)';
        ctx.lineWidth = 1;
        for (let x = 0; x < els.canvas.width; x += 80) {
          ctx.beginPath();
          ctx.moveTo(x + 0.5, 0);
          ctx.lineTo(x + 0.5, els.canvas.height);
          ctx.stroke();
        }
        for (let y = 0; y < els.canvas.height; y += 80) {
          ctx.beginPath();
          ctx.moveTo(0, y + 0.5);
          ctx.lineTo(els.canvas.width, y + 0.5);
          ctx.stroke();
        }
        ctx.restore();
      }

      function renderStage() {
        drawStageBackground();

        if (!state.image) {
          ctx.save();
          ctx.fillStyle = '#dfe6f5';
          ctx.font = '600 26px Segoe UI, sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('Use File > Import Image...', els.canvas.width / 2, els.canvas.height / 2 - 10);
          ctx.font = '400 15px Segoe UI, sans-serif';
          ctx.fillStyle = '#97a0b7';
          ctx.fillText('Black workspace is ready. Drag and zoom are enabled after import.', els.canvas.width / 2, els.canvas.height / 2 + 20);
          ctx.restore();

          setCanvasHasImageClass();
          updateZoomReadout();
          updateStageHintForCurrentTool(false);
          state.cropBox = null;
          state.gradient.preview = null;
          renderSelectionOverlay();
          renderRectangleShapes();
          renderPenOverlay();
          if (zoomTool && typeof zoomTool.render === 'function') zoomTool.render(ctx);
          if (pathSelectionTool && typeof pathSelectionTool.render === 'function') pathSelectionTool.render(ctx);
          if (typeTool && typeof typeTool.render === 'function') typeTool.render(ctx);
          return;
        }

        const rect = getImageDrawRect();
        if (!rect) return;

        ctx.save();
        ctx.shadowColor = 'rgba(0, 0, 0, 0.65)';
        ctx.shadowBlur = 44;
        ctx.shadowOffsetY = 10;
        ctx.fillStyle = 'rgba(255,255,255,0.02)';
        ctx.fillRect(rect.x - 6, rect.y - 6, rect.width + 12, rect.height + 12);
        ctx.restore();

        ctx.save();
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        ctx.drawImage(state.image.element, rect.x, rect.y, rect.width, rect.height);
        ctx.strokeStyle = 'rgba(255,255,255,0.18)';
        ctx.lineWidth = 1;
        ctx.strokeRect(rect.x + 0.5, rect.y + 0.5, rect.width - 1, rect.height - 1);
        ctx.restore();

        ctx.save();
        ctx.strokeStyle = 'rgba(127, 157, 255, 0.12)';
        ctx.lineWidth = 1;
        ctx.setLineDash([6, 6]);
        ctx.strokeRect(rect.x - 12.5, rect.y - 12.5, rect.width + 25, rect.height + 25);
        ctx.restore();

        renderRectangleShapes();
        renderCropOverlay();
        renderSelectionOverlay();
        renderGradientOverlay();
        renderPenOverlay();
        if (zoomTool && typeof zoomTool.render === 'function') zoomTool.render(ctx);
        if (pathSelectionTool && typeof pathSelectionTool.render === 'function') pathSelectionTool.render(ctx);
        if (typeTool && typeof typeTool.render === 'function') typeTool.render(ctx);

        setCanvasHasImageClass();
        updateZoomReadout();
        updateStageHintForCurrentTool(true);
      }

      function renderGradientOverlay() {
        const preview = state.gradient.preview;
        if (!isGradientPreviewUsable(preview)) return;

        const start = preview.start;
        const end = preview.end;
        const dx = end.x - start.x;
        const dy = end.y - start.y;
        const len = Math.max(1, Math.sqrt((dx * dx) + (dy * dy)));
        const nx = dx / len;
        const ny = dy / len;
        const isRadial = state.gradient.type === 'radial';

        ctx.save();
        ctx.lineCap = 'round';

        if (isRadial) {
          ctx.strokeStyle = 'rgba(5, 8, 14, 0.95)';
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.arc(start.x, start.y, len, 0, Math.PI * 2);
          ctx.stroke();

          ctx.setLineDash([7, 5]);
          ctx.strokeStyle = 'rgba(120, 190, 255, 0.95)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(start.x, start.y, len, 0, Math.PI * 2);
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(start.x, start.y);
          ctx.lineTo(end.x, end.y);
          ctx.stroke();
          ctx.setLineDash([]);
        } else {
          ctx.strokeStyle = 'rgba(5, 8, 14, 0.95)';
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.moveTo(start.x, start.y);
          ctx.lineTo(end.x, end.y);
          ctx.stroke();

          ctx.setLineDash([7, 5]);
          ctx.strokeStyle = 'rgba(120, 190, 255, 0.95)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(start.x, start.y);
          ctx.lineTo(end.x, end.y);
          ctx.stroke();
          ctx.setLineDash([]);

          const arrow = 10;
          ctx.fillStyle = 'rgba(120, 190, 255, 0.95)';
          ctx.beginPath();
          ctx.moveTo(end.x, end.y);
          ctx.lineTo(end.x - (nx * arrow) + (ny * 5), end.y - (ny * arrow) - (nx * 5));
          ctx.lineTo(end.x - (nx * arrow) - (ny * 5), end.y - (ny * arrow) + (nx * 5));
          ctx.closePath();
          ctx.fill();
        }

        ctx.fillStyle = 'rgba(255,255,255,0.95)';
        ctx.strokeStyle = 'rgba(10, 12, 18, 0.95)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(start.x, start.y, 4.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = 'rgba(120, 190, 255, 0.95)';
        ctx.beginPath();
        ctx.arc(end.x, end.y, 4.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        ctx.restore();
      }

      function drawCheckerPlaceholder() {
        state.image = null;
        state.view.scale = 1;
        state.view.offsetX = 0;
        state.view.offsetY = 0;
        state.view.fitScale = 1;
        state.selection = null;
        state.cropBox = null;
        clearRectangleShapes({ silent: true });
        state.pen.path = null;
        state.pen.previewPoint = null;
        clearPenSelection();
        state.drag.penAnchorIndex = -1;
        state.drag.penHandleType = null;
        state.drag.penMoved = false;
        if (typeTool && typeof typeTool.clearAll === 'function') typeTool.clearAll({ silent: true });
        renderStage();
      }

      function fitImageToCanvas() {
        if (!state.image) return;
        const pad = 56;
        const fitW = Math.max(32, els.canvas.width - (pad * 2));
        const fitH = Math.max(32, els.canvas.height - (pad * 2));
        const scale = Math.min(fitW / state.image.width, fitH / state.image.height);
        state.view.fitScale = clamp(scale || 1, state.view.minScale, state.view.maxScale);
        state.view.scale = state.view.fitScale;
        state.view.offsetX = 0;
        state.view.offsetY = 0;
        renderStage();
      }

      function setActualSize() {
        if (!state.image) return;
        state.view.scale = clamp(1, state.view.minScale, state.view.maxScale);
        state.view.offsetX = 0;
        state.view.offsetY = 0;
        renderStage();
      }

      function panImage(dx, dy) {
        if (!state.image) return;
        state.view.offsetX += dx;
        state.view.offsetY += dy;
        renderStage();
      }

      function getCanvasCoordsFromPointerEvent(event) {
        const rect = els.canvas.getBoundingClientRect();
        if (!rect.width || !rect.height) return null;
        const scaleX = els.canvas.width / rect.width;
        const scaleY = els.canvas.height / rect.height;
        return {
          x: (event.clientX - rect.left) * scaleX,
          y: (event.clientY - rect.top) * scaleY
        };
      }

      function imageRectToCanvasRect(imageRect) {
        if (!imageRect || !state.image) return null;
        const drawRect = getImageDrawRect();
        if (!drawRect || !drawRect.width || !drawRect.height || !state.image.width || !state.image.height) return null;
        const sx = drawRect.width / state.image.width;
        const sy = drawRect.height / state.image.height;
        const x1 = drawRect.x + ((Number(imageRect.x1) || 0) * sx);
        const y1 = drawRect.y + ((Number(imageRect.y1) || 0) * sy);
        const x2 = drawRect.x + ((Number(imageRect.x2) || 0) * sx);
        const y2 = drawRect.y + ((Number(imageRect.y2) || 0) * sy);
        return {
          x: Math.min(x1, x2),
          y: Math.min(y1, y2),
          width: Math.abs(x2 - x1),
          height: Math.abs(y2 - y1)
        };
      }

      function zoomAtCanvasPoint(canvasX, canvasY, scaleFactor) {
        if (!state.image) return;
        const oldScale = state.view.scale;
        const nextScale = clamp(oldScale * scaleFactor, state.view.minScale, state.view.maxScale);
        if (!Number.isFinite(nextScale) || Math.abs(nextScale - oldScale) < 0.00001) return;

        const center = getCanvasCenter();
        const relX = canvasX - center.x - state.view.offsetX;
        const relY = canvasY - center.y - state.view.offsetY;
        const ratio = nextScale / oldScale;
        state.view.offsetX = (canvasX - center.x) - (relX * ratio);
        state.view.offsetY = (canvasY - center.y) - (relY * ratio);
        state.view.scale = nextScale;
        renderStage();
      }

      function zoomToCanvasRect(canvasRect) {
        if (!state.image || !canvasRect) return false;
        const x = Number(canvasRect.x) || 0;
        const y = Number(canvasRect.y) || 0;
        const w = Math.max(0, Number(canvasRect.width) || 0);
        const h = Math.max(0, Number(canvasRect.height) || 0);
        if (!(w >= 12 && h >= 12)) return false;

        const pad = 56;
        const targetW = Math.max(32, els.canvas.width - (pad * 2));
        const targetH = Math.max(32, els.canvas.height - (pad * 2));
        const factor = Math.min(targetW / w, targetH / h);
        if (!Number.isFinite(factor) || factor <= 0) return false;

        const cx = x + (w / 2);
        const cy = y + (h / 2);
        zoomAtCanvasPoint(cx, cy, factor);

        const center = getCanvasCenter();
        const panX = center.x - cx;
        const panY = center.y - cy;
        if (Math.abs(panX) + Math.abs(panY) > 0.0001) {
          panImage(panX, panY);
        }
        return true;
      }

      function createEditableImageStateFromDrawable(drawable, widthHint, heightHint) {
        const width = Math.max(1, Math.round(widthHint || drawable?.naturalWidth || drawable?.width || 1));
        const height = Math.max(1, Math.round(heightHint || drawable?.naturalHeight || drawable?.height || 1));
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const imageCtx = canvas.getContext('2d', { alpha: true });
        if (!imageCtx) return null;
        imageCtx.imageSmoothingEnabled = true;
        imageCtx.imageSmoothingQuality = 'high';
        imageCtx.clearRect(0, 0, width, height);
        imageCtx.drawImage(drawable, 0, 0, width, height);
        return {
          element: canvas,
          canvas: canvas,
          ctx: imageCtx,
          width,
          height
        };
      }

      function getImagePointFromCanvasPoint(canvasX, canvasY, allowOutsideBounds) {
        if (!state.image) return null;
        const rect = getImageDrawRect();
        if (!rect || rect.width <= 0 || rect.height <= 0) return null;
        if (!allowOutsideBounds) {
          if (canvasX < rect.x || canvasY < rect.y || canvasX > (rect.x + rect.width) || canvasY > (rect.y + rect.height)) {
            return null;
          }
        }
        const x = ((canvasX - rect.x) / rect.width) * state.image.width;
        const y = ((canvasY - rect.y) / rect.height) * state.image.height;
        return {
          x,
          y,
          imageRect: rect
        };
      }

      function getHealScratchCanvas(width, height) {
        if (!state.healBrush.scratchCanvas) {
          state.healBrush.scratchCanvas = document.createElement('canvas');
          state.healBrush.scratchCtx = state.healBrush.scratchCanvas.getContext('2d', { alpha: true });
        }
        const scratchCanvas = state.healBrush.scratchCanvas;
        const scratchCtx = state.healBrush.scratchCtx;
        if (!scratchCanvas || !scratchCtx) return null;
        if (scratchCanvas.width !== width) scratchCanvas.width = width;
        if (scratchCanvas.height !== height) scratchCanvas.height = height;
        return { canvas: scratchCanvas, ctx: scratchCtx };
      }

      function getHealStampCanvas(width, height) {
        if (!state.healBrush.stampCanvas) {
          state.healBrush.stampCanvas = document.createElement('canvas');
          state.healBrush.stampCtx = state.healBrush.stampCanvas.getContext('2d', { alpha: true });
        }
        const stampCanvas = state.healBrush.stampCanvas;
        const stampCtx = state.healBrush.stampCtx;
        if (!stampCanvas || !stampCtx) return null;
        if (stampCanvas.width !== width) stampCanvas.width = width;
        if (stampCanvas.height !== height) stampCanvas.height = height;
        return { canvas: stampCanvas, ctx: stampCtx };
      }

      function getHealPixelAt(data, width, height, x, y) {
        const xi = Math.round(x);
        const yi = Math.round(y);
        if (xi < 0 || yi < 0 || xi >= width || yi >= height) return null;
        const idx = ((yi * width) + xi) * 4;
        return {
          r: data[idx],
          g: data[idx + 1],
          b: data[idx + 2],
          a: data[idx + 3]
        };
      }

      function buildHealRingSamples(targetX, targetY, radiusImage) {
        const samples = [];
        const rings = [Math.max(1, radiusImage * 1.02), Math.max(1.5, radiusImage * 1.18)];
        const count = 18;
        for (let rIndex = 0; rIndex < rings.length; rIndex += 1) {
          const r = rings[rIndex];
          for (let i = 0; i < count; i += 1) {
            const t = (i / count) * Math.PI * 2;
            samples.push({
              ox: Math.cos(t) * r,
              oy: Math.sin(t) * r
            });
          }
        }
        return samples;
      }

      function getHealRingStats(data, width, height, centerX, centerY, sampleOffsets) {
        let totalR = 0;
        let totalG = 0;
        let totalB = 0;
        let totalA = 0;
        let count = 0;
        for (let i = 0; i < sampleOffsets.length; i += 1) {
          const s = sampleOffsets[i];
          const px = getHealPixelAt(data, width, height, centerX + s.ox, centerY + s.oy);
          if (!px) continue;
          totalR += px.r;
          totalG += px.g;
          totalB += px.b;
          totalA += px.a;
          count += 1;
        }
        if (!count) return null;
        return {
          count: count,
          r: totalR / count,
          g: totalG / count,
          b: totalB / count,
          a: totalA / count
        };
      }

      function evaluateHealCandidate(data, width, height, targetX, targetY, sourceX, sourceY, sampleOffsets) {
        let score = 0;
        let valid = 0;
        for (let i = 0; i < sampleOffsets.length; i += 1) {
          const s = sampleOffsets[i];
          const tp = getHealPixelAt(data, width, height, targetX + s.ox, targetY + s.oy);
          const sp = getHealPixelAt(data, width, height, sourceX + s.ox, sourceY + s.oy);
          if (!tp || !sp) continue;
          if (tp.a < 8 || sp.a < 8) continue;
          const dr = tp.r - sp.r;
          const dg = tp.g - sp.g;
          const db = tp.b - sp.b;
          score += Math.abs(dr) + Math.abs(dg) + Math.abs(db);
          valid += 1;
        }
        if (!valid) return null;
        return score / valid;
      }

      function pickAutoHealSource(data, width, height, targetX, targetY, radiusImage) {
        const sampleOffsets = buildHealRingSamples(targetX, targetY, radiusImage);
        let best = null;

        const candidateDistances = [
          Math.max(radiusImage * 1.3, 4),
          Math.max(radiusImage * 1.9, 6),
          Math.max(radiusImage * 2.6, 8)
        ];
        const angleSteps = 16;
        const candidates = [];

        const remembered = state.healBrush.lastSourceOffset;
        if (remembered && Number.isFinite(remembered.x) && Number.isFinite(remembered.y)) {
          candidates.push({
            x: targetX + remembered.x,
            y: targetY + remembered.y,
            remembered: true
          });
        }

        for (let dIndex = 0; dIndex < candidateDistances.length; dIndex += 1) {
          const dist = candidateDistances[dIndex];
          for (let i = 0; i < angleSteps; i += 1) {
            const angle = (i / angleSteps) * Math.PI * 2;
            candidates.push({
              x: targetX + (Math.cos(angle) * dist),
              y: targetY + (Math.sin(angle) * dist),
              remembered: false
            });
          }
        }

        for (let i = 0; i < candidates.length; i += 1) {
          const c = candidates[i];
          if (c.x < 1 || c.y < 1 || c.x >= (width - 1) || c.y >= (height - 1)) continue;
          const score = evaluateHealCandidate(data, width, height, targetX, targetY, c.x, c.y, sampleOffsets);
          if (score === null) continue;
          const dist = distanceBetweenPoints({ x: targetX, y: targetY }, c);
          const rememberedBonus = c.remembered ? -14 : 0;
          const distancePenalty = Math.max(0, (dist - (radiusImage * 2.2)) * 0.4);
          const finalScore = score + distancePenalty + rememberedBonus;
          if (!best || finalScore < best.score) {
            best = { x: c.x, y: c.y, score: finalScore, ringSamples: sampleOffsets };
          }
        }

        if (!best) return null;

        const targetStats = getHealRingStats(data, width, height, targetX, targetY, best.ringSamples);
        const sourceStats = getHealRingStats(data, width, height, best.x, best.y, best.ringSamples);
        best.targetStats = targetStats;
        best.sourceStats = sourceStats;
        return best;
      }

      function applySpotHealAtCanvasPoint(canvasX, canvasY) {
        if (!state.image || !state.image.canvas || !state.image.ctx) return false;
        if (!isCanvasPointInsideActiveSelection(canvasX, canvasY)) return false;
        const mapped = getImagePointFromCanvasPoint(canvasX, canvasY, false);
        if (!mapped) return false;

        const imageCtx = state.image.ctx;
        const imageCanvas = state.image.canvas;
        const imageX = mapped.x;
        const imageY = mapped.y;

        const radiusCanvas = Math.max(4, state.healBrush.sizeCanvasPx / 2);
        const radiusImage = Math.max(2, radiusCanvas / Math.max(0.01, state.view.scale));
        const blendBlurPx = Math.max(0.8, radiusImage * 0.12);
        const margin = Math.max(6, Math.ceil(radiusImage * 4.3));

        const sx = Math.max(0, Math.floor(imageX - radiusImage - margin));
        const sy = Math.max(0, Math.floor(imageY - radiusImage - margin));
        const ex = Math.min(state.image.width, Math.ceil(imageX + radiusImage + margin));
        const ey = Math.min(state.image.height, Math.ceil(imageY + radiusImage + margin));
        const sw = Math.max(1, ex - sx);
        const sh = Math.max(1, ey - sy);

        const scratch = getHealScratchCanvas(sw, sh);
        if (!scratch) return false;
        const scratchCanvas = scratch.canvas;
        const scratchCtx = scratch.ctx;
        scratchCtx.setTransform(1, 0, 0, 1, 0, 0);
        scratchCtx.clearRect(0, 0, sw, sh);
        scratchCtx.drawImage(imageCanvas, sx, sy, sw, sh, 0, 0, sw, sh);

        let localData = null;
        try {
          localData = scratchCtx.getImageData(0, 0, sw, sh);
        } catch (_) {
          localData = null;
        }

        const localTargetX = imageX - sx;
        const localTargetY = imageY - sy;
        let source = null;
        if (localData && localData.data) {
          source = pickAutoHealSource(localData.data, sw, sh, localTargetX, localTargetY, radiusImage);
        }

        if (!source) {
          // Fallback only when texture sampling cannot find a usable nearby patch.
          return applyBlurAtCanvasPoint(canvasX, canvasY);
        }

        state.healBrush.lastSourceOffset = {
          x: source.x - localTargetX,
          y: source.y - localTargetY
        };

        const stamp = getHealStampCanvas(sw, sh);
        if (!stamp) return false;
        const stampCanvas = stamp.canvas;
        const stampCtx = stamp.ctx;
        const shiftX = localTargetX - source.x;
        const shiftY = localTargetY - source.y;

        stampCtx.setTransform(1, 0, 0, 1, 0, 0);
        stampCtx.clearRect(0, 0, sw, sh);
        stampCtx.drawImage(scratchCanvas, shiftX, shiftY);

        // Tone match the cloned patch toward the surrounding target ring to avoid visible seams.
        if (source.targetStats && source.sourceStats) {
          const dr = clamp(source.targetStats.r - source.sourceStats.r, -42, 42);
          const dg = clamp(source.targetStats.g - source.sourceStats.g, -42, 42);
          const db = clamp(source.targetStats.b - source.sourceStats.b, -42, 42);
          if (Math.abs(dr) + Math.abs(dg) + Math.abs(db) > 0.8) {
            try {
              const stampData = stampCtx.getImageData(0, 0, sw, sh);
              const px = stampData.data;
              const toneRadius = Math.max(2, radiusImage * 1.32);
              const x1 = Math.max(0, Math.floor(localTargetX - toneRadius));
              const y1 = Math.max(0, Math.floor(localTargetY - toneRadius));
              const x2 = Math.min(sw, Math.ceil(localTargetX + toneRadius));
              const y2 = Math.min(sh, Math.ceil(localTargetY + toneRadius));
              for (let y = y1; y < y2; y += 1) {
                for (let x = x1; x < x2; x += 1) {
                  const dx = x - localTargetX;
                  const dy = y - localTargetY;
                  const dist = Math.sqrt((dx * dx) + (dy * dy));
                  if (dist > toneRadius) continue;
                  const feather = 1 - (dist / toneRadius);
                  if (feather <= 0) continue;
                  const idx = ((y * sw) + x) * 4;
                  const alpha = px[idx + 3];
                  if (alpha < 2) continue;
                  const mix = feather * 0.55;
                  px[idx] = clamp(Math.round(px[idx] + (dr * mix)), 0, 255);
                  px[idx + 1] = clamp(Math.round(px[idx + 1] + (dg * mix)), 0, 255);
                  px[idx + 2] = clamp(Math.round(px[idx + 2] + (db * mix)), 0, 255);
                }
              }
              stampCtx.putImageData(stampData, 0, 0);
            } catch (_) {}
          }
        }

        // Feather the patch into a circular "spot heal" mask.
        stampCtx.save();
        stampCtx.globalCompositeOperation = 'destination-in';
        const mask = stampCtx.createRadialGradient(
          localTargetX, localTargetY, Math.max(0, radiusImage * 0.48),
          localTargetX, localTargetY, Math.max(1, radiusImage * 1.08)
        );
        mask.addColorStop(0, 'rgba(255,255,255,1)');
        mask.addColorStop(0.75, 'rgba(255,255,255,0.96)');
        mask.addColorStop(1, 'rgba(255,255,255,0)');
        stampCtx.fillStyle = mask;
        stampCtx.fillRect(0, 0, sw, sh);
        stampCtx.restore();

        imageCtx.save();
        imageCtx.globalAlpha = 0.98;
        imageCtx.drawImage(stampCanvas, sx, sy);
        imageCtx.restore();

        // Gentle micro-blend on the inner area to merge clone seams while preserving texture.
        imageCtx.save();
        imageCtx.beginPath();
        imageCtx.arc(imageX, imageY, radiusImage * 0.72, 0, Math.PI * 2);
        imageCtx.clip();
        imageCtx.globalAlpha = 0.14;
        imageCtx.filter = 'blur(' + blendBlurPx + 'px)';
        imageCtx.drawImage(stampCanvas, sx, sy);
        imageCtx.filter = 'none';
        imageCtx.restore();

        state.dirty = true;
        return true;
      }

      function applyBlurAtCanvasPoint(canvasX, canvasY) {
        if (!state.image || !state.image.canvas || !state.image.ctx) return false;
        if (!isCanvasPointInsideActiveSelection(canvasX, canvasY)) return false;
        const mapped = getImagePointFromCanvasPoint(canvasX, canvasY, false);
        if (!mapped) return false;

        const imageCtx = state.image.ctx;
        const imageCanvas = state.image.canvas;
        const imageX = mapped.x;
        const imageY = mapped.y;

        const radiusCanvas = Math.max(4, state.blur.sizeCanvasPx / 2);
        const radiusImage = Math.max(2, radiusCanvas / Math.max(0.01, state.view.scale));
        const blurPx = Math.max(0.8, (Number(state.blur.blurPx) || 6) / Math.max(0.6, state.view.scale));
        const margin = Math.max(4, Math.ceil(radiusImage * 1.9 + blurPx * 2));

        const sx = Math.max(0, Math.floor(imageX - radiusImage - margin));
        const sy = Math.max(0, Math.floor(imageY - radiusImage - margin));
        const ex = Math.min(state.image.width, Math.ceil(imageX + radiusImage + margin));
        const ey = Math.min(state.image.height, Math.ceil(imageY + radiusImage + margin));
        const sw = Math.max(1, ex - sx);
        const sh = Math.max(1, ey - sy);

        const scratch = getHealScratchCanvas(sw, sh);
        if (!scratch) return false;
        const scratchCanvas = scratch.canvas;
        const scratchCtx = scratch.ctx;
        scratchCtx.setTransform(1, 0, 0, 1, 0, 0);
        scratchCtx.clearRect(0, 0, sw, sh);
        scratchCtx.drawImage(imageCanvas, sx, sy, sw, sh, 0, 0, sw, sh);

        imageCtx.save();
        imageCtx.beginPath();
        imageCtx.arc(imageX, imageY, radiusImage, 0, Math.PI * 2);
        imageCtx.clip();
        imageCtx.globalAlpha = clamp(Number(state.blur.opacity || 1), 0, 1);
        imageCtx.filter = 'blur(' + blurPx + 'px)';
        imageCtx.drawImage(scratchCanvas, sx, sy, sw, sh);
        imageCtx.filter = 'none';
        imageCtx.restore();

        // Smaller second pass to reduce hard brush-edge transitions.
        imageCtx.save();
        imageCtx.beginPath();
        imageCtx.arc(imageX, imageY, radiusImage * 0.72, 0, Math.PI * 2);
        imageCtx.clip();
        imageCtx.globalAlpha = clamp((Number(state.blur.opacity || 1) * 0.45), 0, 1);
        imageCtx.filter = 'blur(' + Math.max(0.6, blurPx * 0.7) + 'px)';
        imageCtx.drawImage(scratchCanvas, sx, sy, sw, sh);
        imageCtx.filter = 'none';
        imageCtx.restore();

        state.dirty = true;
        return true;
      }

      function applyDodgeAtCanvasPoint(canvasX, canvasY) {
        if (!state.image || !state.image.canvas || !state.image.ctx) return false;
        if (!isCanvasPointInsideActiveSelection(canvasX, canvasY)) return false;
        const mapped = getImagePointFromCanvasPoint(canvasX, canvasY, false);
        if (!mapped) return false;

        const imageCtx = state.image.ctx;
        const imageX = mapped.x;
        const imageY = mapped.y;

        const radiusCanvas = Math.max(4, state.dodge.sizeCanvasPx / 2);
        const radiusImage = Math.max(2, radiusCanvas / Math.max(0.01, state.view.scale));
        const margin = Math.max(3, Math.ceil(radiusImage * 0.45));

        const sx = Math.max(0, Math.floor(imageX - radiusImage - margin));
        const sy = Math.max(0, Math.floor(imageY - radiusImage - margin));
        const ex = Math.min(state.image.width, Math.ceil(imageX + radiusImage + margin));
        const ey = Math.min(state.image.height, Math.ceil(imageY + radiusImage + margin));
        const sw = Math.max(1, ex - sx);
        const sh = Math.max(1, ey - sy);

        let patch = null;
        try {
          patch = imageCtx.getImageData(sx, sy, sw, sh);
        } catch (_) {
          return false;
        }
        if (!patch || !patch.data) return false;

        const px = patch.data;
        const localX = imageX - sx;
        const localY = imageY - sy;
        const radiusSq = radiusImage * radiusImage;
        const coreRadius = Math.max(1, radiusImage * 0.45);
        const baseOpacity = clamp(Number(state.dodge.opacity || 1), 0, 1);
        const baseStrength = clamp(Number(state.dodge.strength || 0.4), 0.01, 1);

        for (let y = 0; y < sh; y += 1) {
          for (let x = 0; x < sw; x += 1) {
            const dx = x - localX;
            const dy = y - localY;
            const distSq = (dx * dx) + (dy * dy);
            if (distSq > radiusSq) continue;

            const idx = ((y * sw) + x) * 4;
            const alpha = px[idx + 3];
            if (alpha < 2) continue;

            const dist = Math.sqrt(distSq);
            let feather = 1;
            if (dist > coreRadius) {
              feather = 1 - ((dist - coreRadius) / Math.max(0.0001, radiusImage - coreRadius));
            }
            feather = clamp(feather, 0, 1);
            if (feather <= 0) continue;

            const r = px[idx];
            const g = px[idx + 1];
            const b = px[idx + 2];
            const lum = ((r * 0.2126) + (g * 0.7152) + (b * 0.0722)) / 255;

            // Stronger in shadows/midtones, lighter touch in highlights.
            const tonalBias = clamp(1.14 - (lum * 0.9), 0.18, 1.15);
            const highlightProtect = clamp(1 - Math.max(0, (lum - 0.72) / 0.28), 0.08, 1);
            const amount = clamp(baseStrength * baseOpacity * feather * tonalBias * highlightProtect, 0, 0.92);
            if (amount <= 0.0005) continue;

            px[idx] = clamp(Math.round(r + ((255 - r) * amount)), 0, 255);
            px[idx + 1] = clamp(Math.round(g + ((255 - g) * amount)), 0, 255);
            px[idx + 2] = clamp(Math.round(b + ((255 - b) * amount)), 0, 255);
          }
        }

        try {
          imageCtx.putImageData(patch, sx, sy);
        } catch (_) {
          return false;
        }

        state.dirty = true;
        return true;
      }

      function applyBrushAtCanvasPoint(canvasX, canvasY) {
        if (!state.image || !state.image.canvas || !state.image.ctx) return false;
        if (!isCanvasPointInsideActiveSelection(canvasX, canvasY)) return false;
        const mapped = getImagePointFromCanvasPoint(canvasX, canvasY, false);
        if (!mapped) {
          state.brush.lastPoint = null;
          return false;
        }

        const imageCtx = state.image.ctx;
        const radiusCanvas = Math.max(2, state.brush.sizeCanvasPx / 2);
        const radiusImage = Math.max(1, radiusCanvas / Math.max(0.01, state.view.scale));
        const lineWidth = Math.max(1, radiusImage * 2);
        const point = { x: mapped.x, y: mapped.y };
        const prev = state.brush.lastPoint;

        imageCtx.save();
        imageCtx.globalAlpha = clamp(Number(state.brush.opacity || 1), 0, 1);
        imageCtx.strokeStyle = state.brush.color || '#0b0b0d';
        imageCtx.fillStyle = state.brush.color || '#0b0b0d';
        imageCtx.lineWidth = lineWidth;
        imageCtx.lineCap = 'round';
        imageCtx.lineJoin = 'round';

        if (prev) {
          imageCtx.beginPath();
          imageCtx.moveTo(prev.x, prev.y);
          imageCtx.lineTo(point.x, point.y);
          imageCtx.stroke();
        } else {
          imageCtx.beginPath();
          imageCtx.arc(point.x, point.y, radiusImage, 0, Math.PI * 2);
          imageCtx.fill();
        }

        // Reinforce the stroke endpoint so slow drags do not leave gaps.
        imageCtx.beginPath();
        imageCtx.arc(point.x, point.y, radiusImage, 0, Math.PI * 2);
        imageCtx.fill();
        imageCtx.restore();

        state.brush.lastPoint = point;
        state.dirty = true;
        return true;
      }

      function applyEraserAtCanvasPoint(canvasX, canvasY) {
        if (!state.image || !state.image.canvas || !state.image.ctx) return false;
        if (!isCanvasPointInsideActiveSelection(canvasX, canvasY)) return false;
        const mapped = getImagePointFromCanvasPoint(canvasX, canvasY, false);
        if (!mapped) {
          state.eraser.lastPoint = null;
          return false;
        }

        const imageCtx = state.image.ctx;
        const radiusCanvas = Math.max(2, state.eraser.sizeCanvasPx / 2);
        const radiusImage = Math.max(1, radiusCanvas / Math.max(0.01, state.view.scale));
        const lineWidth = Math.max(1, radiusImage * 2);
        const point = { x: mapped.x, y: mapped.y };
        const prev = state.eraser.lastPoint;

        imageCtx.save();
        imageCtx.globalCompositeOperation = 'destination-out';
        imageCtx.globalAlpha = clamp(Number(state.eraser.opacity || 1), 0, 1);
        imageCtx.strokeStyle = '#000';
        imageCtx.fillStyle = '#000';
        imageCtx.lineWidth = lineWidth;
        imageCtx.lineCap = 'round';
        imageCtx.lineJoin = 'round';

        if (prev) {
          imageCtx.beginPath();
          imageCtx.moveTo(prev.x, prev.y);
          imageCtx.lineTo(point.x, point.y);
          imageCtx.stroke();
        } else {
          imageCtx.beginPath();
          imageCtx.arc(point.x, point.y, radiusImage, 0, Math.PI * 2);
          imageCtx.fill();
        }

        imageCtx.beginPath();
        imageCtx.arc(point.x, point.y, radiusImage, 0, Math.PI * 2);
        imageCtx.fill();
        imageCtx.restore();

        state.eraser.lastPoint = point;
        state.dirty = true;
        return true;
      }

      function applyGradientFromCanvasPoints(startCanvasX, startCanvasY, endCanvasX, endCanvasY) {
        if (!state.image || !state.image.canvas || !state.image.ctx) return false;

        const startMapped = getImagePointFromCanvasPoint(startCanvasX, startCanvasY, true);
        const endMapped = getImagePointFromCanvasPoint(endCanvasX, endCanvasY, true);
        if (!startMapped || !endMapped) return false;

        const startPoint = { x: startMapped.x, y: startMapped.y };
        const endPoint = { x: endMapped.x, y: endMapped.y };
        if (distanceBetweenPoints(startPoint, endPoint) < 0.5) {
          endPoint.x += 1;
        }

        const imageCtx = state.image.ctx;
        const gradientCfg = state.gradient || {};
        let gradient = null;

        if (gradientCfg.type === 'radial') {
          const radius = Math.max(1, distanceBetweenPoints(startPoint, endPoint));
          gradient = imageCtx.createRadialGradient(startPoint.x, startPoint.y, 0, startPoint.x, startPoint.y, radius);
        } else {
          gradient = imageCtx.createLinearGradient(startPoint.x, startPoint.y, endPoint.x, endPoint.y);
        }

        const stops = [
          { offset: 0, color: gradientCfg.startColor || '#ffffff', alpha: 1 }
        ];
        if (gradientCfg.useMidStop) {
          stops.push({
            offset: clamp(Number(gradientCfg.midStop || 0.5), 0.05, 0.95),
            color: gradientCfg.midColor || '#ffd166',
            alpha: 1
          });
        }
        stops.push({
          offset: 1,
          color: gradientCfg.endColor || '#000000',
          alpha: gradientCfg.fadeEnd ? 0 : 1
        });

        stops
          .sort(function (a, b) { return a.offset - b.offset; })
          .forEach(function (stop, index) {
            const prev = stops[index - 1];
            let offset = clamp(Number(stop.offset), 0, 1);
            if (prev && offset <= prev.offset) offset = Math.min(1, prev.offset + 0.0001);
            gradient.addColorStop(offset, colorToRgbaString(stop.color, stop.alpha, [255, 255, 255]));
          });

        imageCtx.save();
        imageCtx.globalCompositeOperation = String(gradientCfg.blendMode || 'source-over');
        imageCtx.globalAlpha = clamp(Number(gradientCfg.opacity || 1), 0, 1);
        imageCtx.fillStyle = gradient;
        imageCtx.fillRect(0, 0, state.image.width, state.image.height);
        imageCtx.restore();

        state.dirty = true;
        return true;
      }

      function applyPenPathToImage() {
        if (!state.image || !state.image.ctx) {
          setStatus('No image to apply the pen path to. Import an image first.', 'info');
          return false;
        }
        if (!isPenPathUsable(state.pen.path)) {
          setStatus('Create a pen path with at least two anchors first.', 'info');
          return false;
        }

        const drawRect = getImageDrawRect();
        if (!drawRect || drawRect.width <= 0 || drawRect.height <= 0) {
          setStatus('Pen apply failed: invalid image view.', 'error');
          return false;
        }

        const scaleX = state.image.width / drawRect.width;
        const scaleY = state.image.height / drawRect.height;
        const sourcePath = state.pen.path;
        const mappedPath = {
          closed: !!sourcePath.closed,
          points: sourcePath.points.map(function (anchor) {
            function mapPoint(pt) {
              if (!pt) return null;
              return {
                x: (pt.x - drawRect.x) * scaleX,
                y: (pt.y - drawRect.y) * scaleY
              };
            }
            const mappedAnchor = mapPoint(anchor);
            mappedAnchor.in = mapPoint(anchor.in);
            mappedAnchor.out = mapPoint(anchor.out);
            return mappedAnchor;
          })
        };

        const imageCtx = state.image.ctx;
        const strokeWidth = Math.max(0.75, Number(state.pen.strokeWidthCanvasPx || 2.8) / Math.max(0.01, state.view.scale));

        imageCtx.save();
        imageCtx.lineCap = 'round';
        imageCtx.lineJoin = 'round';
        if (!buildPenCanvasPath(mappedPath, imageCtx)) {
          imageCtx.restore();
          setStatus('Pen apply failed. Please redraw the path.', 'error');
          return false;
        }
        if (mappedPath.closed && mappedPath.points.length >= 3 && Number(state.pen.fillOpacity || 0) > 0.001) {
          imageCtx.fillStyle = colorToRgbaString(state.pen.fillColor || '#84b5ff', Number(state.pen.fillOpacity || 0.12), [132, 181, 255]);
          imageCtx.fill();
          buildPenCanvasPath(mappedPath, imageCtx);
        }
        imageCtx.lineWidth = strokeWidth;
        imageCtx.strokeStyle = colorToRgbaString(state.pen.strokeColor || '#84b5ff', Number(state.pen.strokeOpacity || 0.95), [132, 181, 255]);
        imageCtx.stroke();
        imageCtx.restore();

        state.dirty = true;
        const wasClosed = !!mappedPath.closed;
        const anchorCount = mappedPath.points.length;
        clearPenPath({ silent: true });
        pushHistory(wasClosed ? 'Pen path fill/stroke' : 'Pen path stroke');
        setStatus((wasClosed ? 'Closed pen path applied' : 'Pen path stroke applied') + ' (' + anchorCount + ' anchors).', 'success');
        return true;
      }

      function drawImageContain(img) {
        state.selection = null;
        state.cropBox = null;
        state.gradient.preview = null;
        clearRectangleShapes({ silent: true });
        state.pen.path = null;
        state.pen.previewPoint = null;
        clearPenSelection();
        state.drag.penAnchorIndex = -1;
        state.drag.penHandleType = null;
        state.drag.penMoved = false;
        if (typeTool && typeof typeTool.clearAll === 'function') typeTool.clearAll({ silent: true });
        state.brush.lastPoint = null;
        state.brush.activeStroke = false;
        state.eraser.lastPoint = null;
        state.eraser.activeStroke = false;
        state.blur.activeStroke = false;
        state.dodge.activeStroke = false;
        state.healBrush.lastSourceOffset = null;
        const editable = createEditableImageStateFromDrawable(img);
        if (!editable) return;
        state.image = editable;
        fitImageToCanvas();
      }

      async function applyCropToImage() {
        if (!state.image) {
          setStatus('No image to crop. Import an image first.', 'info');
          return;
        }
        if (!isCropBoxUsable(state.cropBox)) {
          setStatus('Create a crop box first, then press Enter to apply crop.', 'info');
          return;
        }

        const drawRect = getImageDrawRect();
        if (!drawRect || drawRect.width <= 0 || drawRect.height <= 0) {
          setStatus('Crop failed: invalid image view.', 'error');
          return;
        }

        const crop = state.cropBox;
        const interX1 = Math.max(crop.x, drawRect.x);
        const interY1 = Math.max(crop.y, drawRect.y);
        const interX2 = Math.min(crop.x + crop.width, drawRect.x + drawRect.width);
        const interY2 = Math.min(crop.y + crop.height, drawRect.y + drawRect.height);
        const interW = interX2 - interX1;
        const interH = interY2 - interY1;
        if (!(interW > 0.5 && interH > 0.5)) {
          setStatus('Crop box does not overlap the image.', 'error');
          return;
        }

        const scaleX = state.image.width / drawRect.width;
        const scaleY = state.image.height / drawRect.height;

        const srcXf = (interX1 - drawRect.x) * scaleX;
        const srcYf = (interY1 - drawRect.y) * scaleY;
        const srcWf = interW * scaleX;
        const srcHf = interH * scaleY;

        const srcX = clamp(Math.floor(srcXf), 0, Math.max(0, state.image.width - 1));
        const srcY = clamp(Math.floor(srcYf), 0, Math.max(0, state.image.height - 1));
        const srcX2 = clamp(Math.ceil(srcXf + srcWf), srcX + 1, state.image.width);
        const srcY2 = clamp(Math.ceil(srcYf + srcHf), srcY + 1, state.image.height);
        const srcW = Math.max(1, srcX2 - srcX);
        const srcH = Math.max(1, srcY2 - srcY);

        try {
          const tempCanvas = document.createElement('canvas');
          tempCanvas.width = srcW;
          tempCanvas.height = srcH;
          const tempCtx = tempCanvas.getContext('2d', { alpha: true });
          if (!tempCtx) {
            setStatus('Crop failed: canvas context unavailable.', 'error');
            return;
          }

          tempCtx.imageSmoothingEnabled = true;
          tempCtx.imageSmoothingQuality = 'high';
          tempCtx.clearRect(0, 0, srcW, srcH);
          tempCtx.drawImage(state.image.element, srcX, srcY, srcW, srcH, 0, 0, srcW, srcH);

          const editable = createEditableImageStateFromDrawable(tempCanvas, srcW, srcH);
          if (!editable) {
            setStatus('Crop failed: canvas buffer unavailable.', 'error');
            return;
          }
          state.image = editable;
          state.cropBox = null;
          state.selection = null;
          state.gradient.preview = null;
          cropRectangleShapes({
            srcX: srcX,
            srcY: srcY,
            srcW: srcW,
            srcH: srcH
          });
          state.pen.path = null;
          state.pen.previewPoint = null;
          clearPenSelection();
          state.drag.penAnchorIndex = -1;
          state.drag.penHandleType = null;
          state.drag.penMoved = false;
          if (typeTool && typeof typeTool.onCropApplied === 'function') {
            typeTool.onCropApplied({
              srcX: srcX,
              srcY: srcY,
              srcW: srcW,
              srcH: srcH
            });
          }
          state.brush.lastPoint = null;
          state.brush.activeStroke = false;
          state.eraser.lastPoint = null;
          state.eraser.activeStroke = false;
          state.blur.activeStroke = false;
          state.dodge.activeStroke = false;
          state.healBrush.lastSourceOffset = null;
          state.dirty = true;
          fitImageToCanvas();
          pushHistory('Crop image');
          setStatus('Crop applied (' + state.image.width + 'x' + state.image.height + ').', 'success');
        } catch (error) {
          console.error('[ImageEditor] Crop failed:', error);
          setStatus('Crop failed. Please try again.', 'error');
        }
      }

      function sanitizeBaseName(name) {
        const raw = String(name || 'image-editor-export');
        const withoutExt = raw.replace(/\.[^.]+$/, '');
        return withoutExt.replace(/[<>:\"/\\|?*\x00-\x1F]/g, '-').replace(/\s+/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '') || 'image-editor-export';
      }

      function closeFileMenu() {
        if (!els.fileMenuDropdown || els.fileMenuDropdown.hidden) return;
        els.fileMenuDropdown.hidden = true;
        if (els.fileMenuBtn) els.fileMenuBtn.setAttribute('aria-expanded', 'false');
      }

      function toggleFileMenu() {
        if (!els.fileMenuDropdown) return;
        const isOpening = els.fileMenuDropdown.hidden;
        els.fileMenuDropdown.hidden = !isOpening;
        if (els.fileMenuBtn) els.fileMenuBtn.setAttribute('aria-expanded', String(isOpening));
      }

      function loadImageFromDataUrl(dataUrl) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => resolve(img);
          img.onerror = () => reject(new Error('Could not load selected image.'));
          img.src = dataUrl;
        });
      }

      function openImageFallback() {
        return new Promise((resolve) => {
          const input = document.createElement('input');
          input.type = 'file';
          input.accept = 'image/*';
          input.style.display = 'none';
          document.body.appendChild(input);
          input.addEventListener('change', () => {
            const file = input.files && input.files[0];
            if (!file) {
              input.remove();
              resolve(null);
              return;
            }
            const reader = new FileReader();
            reader.onload = () => {
              input.remove();
              resolve({ dataUrl: String(reader.result || ''), fileName: file.name || null });
            };
            reader.onerror = () => {
              input.remove();
              resolve(null);
            };
            reader.readAsDataURL(file);
          }, { once: true });
          input.click();
        });
      }

      async function importImage() {
        closeFileMenu();
        setStatus('Opening image...', 'info');
        try {
          let dataUrl = null;
          let fileName = null;

          if (window.browserAPI && window.browserAPI.files && typeof window.browserAPI.files.openImage === 'function') {
            dataUrl = await window.browserAPI.files.openImage();
          } else {
            const fallback = await openImageFallback();
            dataUrl = fallback && fallback.dataUrl;
            fileName = fallback && fallback.fileName;
          }

          if (!dataUrl) {
            setStatus('Import cancelled.', 'info');
            return;
          }

          const img = await loadImageFromDataUrl(dataUrl);
          drawImageContain(img);
          state.dirty = true;

          if (!fileName) fileName = 'Imported Image';
          setDocName(fileName);
          pushHistory('Import image');
          setStatus('Image imported. Save changes to export PNG.', 'success');
        } catch (error) {
          console.error('[ImageEditor] Import failed:', error);
          setStatus('Import failed. Try another image.', 'error');
          pushHistory('Import failed', true);
        }
      }

      async function saveChanges() {
        closeFileMenu();
        setStatus('Preparing image export...', 'info');
        try {
          const dataUrl = els.canvas.toDataURL('image/png');
          const defaultName = sanitizeBaseName(state.docName) + '.png';

          if (window.browserAPI && window.browserAPI.files && typeof window.browserAPI.files.saveImage === 'function') {
            const result = await window.browserAPI.files.saveImage(dataUrl, defaultName);
            if (!result || result.success !== true) {
              setStatus(result && result.error ? ('Save failed: ' + result.error) : 'Save cancelled.', result && result.error ? 'error' : 'info');
              if (result && result.error) pushHistory('Save failed', true);
              return;
            }
            state.dirty = false;
            pushHistory('Save changes');
            setStatus('Saved successfully: ' + (result.filePath || defaultName), 'success');
            return;
          }

          const a = document.createElement('a');
          a.href = dataUrl;
          a.download = defaultName;
          document.body.appendChild(a);
          a.click();
          a.remove();
          state.dirty = false;
          pushHistory('Save changes');
          setStatus('Save started (browser download).', 'success');
        } catch (error) {
          console.error('[ImageEditor] Save failed:', error);
          setStatus('Save failed. Please try again.', 'error');
          pushHistory('Save failed', true);
        }
      }

      function newBlankCanvas() {
        closeFileMenu();
        drawCheckerPlaceholder();
        setDocName('New Project.psd');
        state.dirty = false;
        pushHistory('New blank canvas');
        setStatus('Blank canvas ready.', 'success');
      }

      function onGradientControlsChanged(markCustom) {
        if (markCustom !== false) markGradientPresetCustom();
        updateGradientControlsUi();
        if (state.activeTool === 'gradient') renderStage();
      }

      function onRectangleControlsChanged() {
        updateRectangleControlsUi();
        if (state.activeTool === 'rectangle') renderStage();
      }

      function resetDefaultColors() {
        const foreground = '#000000';
        const background = '#ffffff';
        let changedVisibleContent = false;

        state.brush.color = foreground;

        state.pen.strokeColor = foreground;
        state.pen.fillColor = background;

        state.gradient.startColor = foreground;
        state.gradient.midColor = '#808080';
        state.gradient.endColor = background;
        markGradientPresetCustom();

        if (state.rectangleTool && state.rectangleTool.defaults) {
          state.rectangleTool.defaults.strokeColor = foreground;
          state.rectangleTool.defaults.fillColor = background;
        }

        const selectedRect = getSelectedRectangleShape();
        if (selectedRect) {
          selectedRect.strokeColor = foreground;
          selectedRect.fillColor = background;
          ensureRectangleRadiusWithinBounds(selectedRect);
          changedVisibleContent = true;
        }

        if (changedVisibleContent) state.dirty = true;
        updateGradientControlsUi();
        updateRectangleControlsUi();
        renderStage();
        setStatus('Default colors restored (black/white).' + (changedVisibleContent ? ' Selected rectangle colors updated.' : ''), 'success');
      }

      if (els.fileMenuBtn) {
        els.fileMenuBtn.addEventListener('click', function (event) {
          event.stopPropagation();
          toggleFileMenu();
        });
      }
      if (els.fileMenuDropdown) {
        els.fileMenuDropdown.addEventListener('click', function (event) {
          event.stopPropagation();
        });
      }
      if (els.fileImportBtn) els.fileImportBtn.addEventListener('click', importImage);
      if (els.fileSaveBtn) els.fileSaveBtn.addEventListener('click', saveChanges);
      if (els.fileNewBtn) els.fileNewBtn.addEventListener('click', newBlankCanvas);
      if (els.moveToolBtn) els.moveToolBtn.addEventListener('click', function () { setActiveTool('move'); });
      if (els.marqueeToolBtn) els.marqueeToolBtn.addEventListener('click', function () { setActiveTool('marquee'); });
      if (els.lassoToolBtn) els.lassoToolBtn.addEventListener('click', function () { setActiveTool('lasso'); });
      if (els.cropToolBtn) els.cropToolBtn.addEventListener('click', function () { setActiveTool('crop'); });
      if (els.healToolBtn) els.healToolBtn.addEventListener('click', function () { setActiveTool('heal'); });
      if (els.brushToolBtn) els.brushToolBtn.addEventListener('click', function () { setActiveTool('brush'); });
      if (els.eraserToolBtn) els.eraserToolBtn.addEventListener('click', function () { setActiveTool('eraser'); });
      if (els.gradientToolBtn) els.gradientToolBtn.addEventListener('click', function () { setActiveTool('gradient'); });
      if (els.rectangleToolBtn) els.rectangleToolBtn.addEventListener('click', function () { setActiveTool('rectangle'); });
      if (els.blurToolBtn) els.blurToolBtn.addEventListener('click', function () { setActiveTool('blur'); });
      if (els.dodgeToolBtn) els.dodgeToolBtn.addEventListener('click', function () { setActiveTool('dodge'); });
      if (els.penToolBtn) els.penToolBtn.addEventListener('click', function () { setActiveTool('pen'); });
      if (els.pathSelectToolBtn) els.pathSelectToolBtn.addEventListener('click', function () { setActiveTool('path-select'); });
      if (els.handToolBtn) els.handToolBtn.addEventListener('click', function () { setActiveTool('hand'); });
      if (els.zoomToolBtn) els.zoomToolBtn.addEventListener('click', function () { setActiveTool('zoom'); });
      if (els.defaultColorsBtn) els.defaultColorsBtn.addEventListener('click', resetDefaultColors);
      if (els.typeToolBtn) els.typeToolBtn.addEventListener('click', function () { setActiveTool('type'); });

      if (els.gradientTypeSelect) {
        els.gradientTypeSelect.addEventListener('change', function () {
          state.gradient.type = els.gradientTypeSelect.value === 'radial' ? 'radial' : 'linear';
          onGradientControlsChanged(true);
        });
      }
      if (els.gradientBlendSelect) {
        els.gradientBlendSelect.addEventListener('change', function () {
          state.gradient.blendMode = String(els.gradientBlendSelect.value || 'source-over');
          onGradientControlsChanged(true);
        });
      }
      if (els.gradientFadeEndCheckbox) {
        els.gradientFadeEndCheckbox.addEventListener('change', function () {
          state.gradient.fadeEnd = !!els.gradientFadeEndCheckbox.checked;
          onGradientControlsChanged(true);
        });
      }
      if (els.gradientMidToggleCheckbox) {
        els.gradientMidToggleCheckbox.addEventListener('change', function () {
          state.gradient.useMidStop = !!els.gradientMidToggleCheckbox.checked;
          onGradientControlsChanged(true);
        });
      }
      if (els.gradientStartColorInput) {
        els.gradientStartColorInput.addEventListener('input', function () {
          state.gradient.startColor = String(els.gradientStartColorInput.value || '#ffffff');
          onGradientControlsChanged(true);
        });
      }
      if (els.gradientMidColorInput) {
        els.gradientMidColorInput.addEventListener('input', function () {
          state.gradient.midColor = String(els.gradientMidColorInput.value || '#ffd166');
          onGradientControlsChanged(true);
        });
      }
      if (els.gradientEndColorInput) {
        els.gradientEndColorInput.addEventListener('input', function () {
          state.gradient.endColor = String(els.gradientEndColorInput.value || '#000000');
          onGradientControlsChanged(true);
        });
      }
      if (els.gradientOpacityRange) {
        els.gradientOpacityRange.addEventListener('input', function () {
          state.gradient.opacity = clamp((Number(els.gradientOpacityRange.value) || 85) / 100, 0.05, 1);
          onGradientControlsChanged(true);
        });
      }
      if (els.gradientReverseBtn) {
        els.gradientReverseBtn.addEventListener('click', function () {
          const temp = state.gradient.startColor;
          state.gradient.startColor = state.gradient.endColor;
          state.gradient.endColor = temp;
          onGradientControlsChanged(true);
          setStatus('Gradient colors reversed.', 'success');
        });
      }

      function applyRectangleControlPatch(mutator, statusMessage) {
        const target = getRectangleControlsTarget();
        if (!target || typeof mutator !== 'function') return;
        mutator(target);
        if (target !== (state.rectangleTool && state.rectangleTool.defaults)) {
          ensureRectangleRadiusWithinBounds(target);
          state.dirty = true;
        }
        onRectangleControlsChanged();
        if (statusMessage) setStatus(statusMessage, 'success');
      }

      if (els.rectangleBlendSelect) {
        els.rectangleBlendSelect.addEventListener('change', function () {
          applyRectangleControlPatch(function (target) {
            target.blendMode = String(els.rectangleBlendSelect.value || 'source-over');
          }, 'Rectangle blend mode updated.');
        });
      }
      if (els.rectangleFillEnable) {
        els.rectangleFillEnable.addEventListener('change', function () {
          applyRectangleControlPatch(function (target) {
            target.fillEnabled = !!els.rectangleFillEnable.checked;
          }, 'Rectangle fill ' + (els.rectangleFillEnable.checked ? 'enabled.' : 'disabled.'));
        });
      }
      if (els.rectangleFillColor) {
        els.rectangleFillColor.addEventListener('input', function () {
          applyRectangleControlPatch(function (target) {
            target.fillColor = String(els.rectangleFillColor.value || '#84b5ff');
          });
        });
      }
      if (els.rectangleFillOpacityRange) {
        els.rectangleFillOpacityRange.addEventListener('input', function () {
          applyRectangleControlPatch(function (target) {
            target.fillOpacity = clamp((Number(els.rectangleFillOpacityRange.value) || 0) / 100, 0, 1);
          });
        });
      }
      if (els.rectangleStrokeEnable) {
        els.rectangleStrokeEnable.addEventListener('change', function () {
          applyRectangleControlPatch(function (target) {
            target.strokeEnabled = !!els.rectangleStrokeEnable.checked;
          }, 'Rectangle stroke ' + (els.rectangleStrokeEnable.checked ? 'enabled.' : 'disabled.'));
        });
      }
      if (els.rectangleStrokeColor) {
        els.rectangleStrokeColor.addEventListener('input', function () {
          applyRectangleControlPatch(function (target) {
            target.strokeColor = String(els.rectangleStrokeColor.value || '#84b5ff');
          });
        });
      }
      if (els.rectangleStrokeWidthRange) {
        els.rectangleStrokeWidthRange.addEventListener('input', function () {
          applyRectangleControlPatch(function (target) {
            target.strokeWidth = clamp(Number(els.rectangleStrokeWidthRange.value) || 0, 0, 400);
          });
        });
      }
      if (els.rectangleStrokeOpacityRange) {
        els.rectangleStrokeOpacityRange.addEventListener('input', function () {
          applyRectangleControlPatch(function (target) {
            target.strokeOpacity = clamp((Number(els.rectangleStrokeOpacityRange.value) || 0) / 100, 0, 1);
          });
        });
      }
      if (els.rectangleRadiusRange) {
        els.rectangleRadiusRange.addEventListener('input', function () {
          applyRectangleControlPatch(function (target) {
            target.radius = clamp(Number(els.rectangleRadiusRange.value) || 0, 0, 1000);
          });
        });
      }

      if (els.canvas) {
        els.canvas.addEventListener('dblclick', function (event) {
          if (state.activeTool === 'crop' && isCropBoxUsable(state.cropBox)) {
            applyCropToImage();
            return;
          }
          if ((state.activeTool === 'pen' || state.activeTool === 'path-select') && isPenPathUsable(state.pen.path)) {
            applyPenPathToImage();
            return;
          }
          if (state.activeTool === 'type' && typeTool && typeof typeTool.handleDoubleClick === 'function') {
            const point = getCanvasCoordsFromPointerEvent(event);
            if (point && typeTool.handleDoubleClick(point, event)) return;
          }
          if (!state.image) return;
          fitImageToCanvas();
          setStatus('View fit to canvas.', 'success');
        });

        els.canvas.addEventListener('wheel', function (event) {
          if (!state.image) return;
          event.preventDefault();

          const rect = els.canvas.getBoundingClientRect();
          if (!rect.width || !rect.height) return;
          const scaleX = els.canvas.width / rect.width;
          const scaleY = els.canvas.height / rect.height;
          const point = getCanvasCoordsFromPointerEvent(event) || getCanvasCenter();

          if (event.ctrlKey || event.metaKey) {
            const factor = Math.exp(-event.deltaY * 0.0018);
            zoomAtCanvasPoint(point.x, point.y, factor);
            return;
          }

          let panX = -event.deltaX * scaleX;
          let panY = -event.deltaY * scaleY;
          if (event.shiftKey && Math.abs(event.deltaX) < 0.01) {
            panX = -event.deltaY * scaleX;
            panY = 0;
          }

          panImage(panX, panY);
        }, { passive: false });

        els.canvas.addEventListener('pointerdown', function (event) {
          if (!state.image && state.activeTool !== 'marquee' && state.activeTool !== 'lasso' && state.activeTool !== 'type' && state.activeTool !== 'rectangle' && state.activeTool !== 'hand' && state.activeTool !== 'zoom') return;
          if (event.button !== 0) return;
          event.preventDefault();

          const point = getCanvasCoordsFromPointerEvent(event);
          if (!point) return;

          state.drag.active = true;
          state.drag.pointerId = event.pointerId;
          state.drag.startX = point.x;
          state.drag.startY = point.y;
          state.drag.lastX = point.x;
          state.drag.lastY = point.y;
          state.drag.penAnchorIndex = -1;
          state.drag.penHandleType = null;
          state.drag.penMoved = false;
          state.drag.rectShapeId = null;
          state.drag.rectHandle = null;
          state.drag.rectMoved = false;
          state.drag.rectStartImagePoint = null;
          state.drag.rectStartGeom = null;
          if (state.activeTool === 'marquee') {
            state.drag.mode = 'marquee';
            setSelectionFromPoints(point.x, point.y, point.x, point.y, !!event.shiftKey);
            renderStage();
          } else if (state.activeTool === 'lasso') {
            state.drag.mode = 'lasso';
            state.drag.lassoPoints = [clonePoint(point)];
            state.selection = createLassoSelectionFromPoints(state.drag.lassoPoints, false);
            renderStage();
          } else if (state.activeTool === 'crop') {
            if (!state.image) {
              state.drag.active = false;
              state.drag.pointerId = null;
              return;
            }
            state.drag.mode = 'crop';
            state.cropBox = createCropBoxFromPoints(point.x, point.y, point.x, point.y, !!event.shiftKey);
            renderStage();
          } else if (state.activeTool === 'heal') {
            if (!state.image) {
              state.drag.active = false;
              state.drag.pointerId = null;
              return;
            }
            state.drag.mode = 'heal';
            state.healBrush.activeStroke = false;
            state.healBrush.lastSourceOffset = null;
            if (applySpotHealAtCanvasPoint(point.x, point.y)) {
              state.healBrush.activeStroke = true;
              renderStage();
            }
          } else if (state.activeTool === 'brush') {
            if (!state.image) {
              state.drag.active = false;
              state.drag.pointerId = null;
              return;
            }
            state.drag.mode = 'brush';
            state.brush.activeStroke = false;
            state.brush.lastPoint = null;
            if (applyBrushAtCanvasPoint(point.x, point.y)) {
              state.brush.activeStroke = true;
              renderStage();
            }
          } else if (state.activeTool === 'eraser') {
            if (!state.image) {
              state.drag.active = false;
              state.drag.pointerId = null;
              return;
            }
            state.drag.mode = 'eraser';
            state.eraser.activeStroke = false;
            state.eraser.lastPoint = null;
            if (applyEraserAtCanvasPoint(point.x, point.y)) {
              state.eraser.activeStroke = true;
              renderStage();
            }
          } else if (state.activeTool === 'blur') {
            if (!state.image) {
              state.drag.active = false;
              state.drag.pointerId = null;
              return;
            }
            state.drag.mode = 'blur';
            state.blur.activeStroke = false;
            if (applyBlurAtCanvasPoint(point.x, point.y)) {
              state.blur.activeStroke = true;
              renderStage();
            }
          } else if (state.activeTool === 'dodge') {
            if (!state.image) {
              state.drag.active = false;
              state.drag.pointerId = null;
              return;
            }
            state.drag.mode = 'dodge';
            state.dodge.activeStroke = false;
            if (applyDodgeAtCanvasPoint(point.x, point.y)) {
              state.dodge.activeStroke = true;
              renderStage();
            }
          } else if (state.activeTool === 'gradient') {
            if (!state.image) {
              state.drag.active = false;
              state.drag.pointerId = null;
              return;
            }
            state.drag.mode = 'gradient';
            setGradientPreviewFromPoints(point.x, point.y, point.x, point.y);
            renderStage();
          } else if (state.activeTool === 'rectangle') {
            if (!state.image) {
              state.drag.active = false;
              state.drag.pointerId = null;
              setStatus('Import an image first to create rectangle shapes.', 'info');
              return;
            }
            const mapped = getImagePointFromCanvasPoint(point.x, point.y, true);
            if (!mapped) {
              state.drag.active = false;
              state.drag.pointerId = null;
              return;
            }
            const handleHit = getRectangleHandleHitAtCanvasPoint(point);
            if (handleHit && handleHit.kind === 'handle') {
              const shape = getRectangleShapeById(handleHit.shapeId);
              if (!shape) {
                state.drag.active = false;
                state.drag.pointerId = null;
                return;
              }
              state.drag.mode = 'rectangle-resize';
              state.drag.rectShapeId = shape.id;
              state.drag.rectHandle = handleHit.handle;
              state.drag.rectStartImagePoint = { x: mapped.x, y: mapped.y };
              state.drag.rectStartGeom = copyRectangleGeometry(shape);
              setRectangleSelectedId(shape.id, { silentRender: true });
              renderStage();
            } else {
              const shapeHit = hitTestRectangleShapeAtCanvasPoint(point);
              if (shapeHit && shapeHit.kind === 'shape') {
                const shape = getRectangleShapeById(shapeHit.shapeId);
                if (!shape) {
                  state.drag.active = false;
                  state.drag.pointerId = null;
                  return;
                }
                state.drag.mode = 'rectangle-move';
                state.drag.rectShapeId = shape.id;
                state.drag.rectHandle = 'move';
                state.drag.rectStartImagePoint = { x: mapped.x, y: mapped.y };
                state.drag.rectStartGeom = copyRectangleGeometry(shape);
                setRectangleSelectedId(shape.id, { silentRender: true });
                renderStage();
              } else {
                const newShape = createRectangleShapeFromGeometry({
                  x: mapped.x,
                  y: mapped.y,
                  width: 0,
                  height: 0
                });
                state.rectangleTool.shapes.push(newShape);
                state.rectangleTool.selectedId = newShape.id;
                state.drag.mode = 'rectangle-create';
                state.drag.rectShapeId = newShape.id;
                state.drag.rectHandle = 'create';
                state.drag.rectStartImagePoint = { x: mapped.x, y: mapped.y };
                state.drag.rectStartGeom = copyRectangleGeometry(newShape);
                updateRectangleControlsUi();
                renderStage();
              }
            }
          } else if (state.activeTool === 'pen') {
            if (!state.image) {
              state.drag.active = false;
              state.drag.pointerId = null;
              return;
            }
            state.pen.previewPoint = null;
            const hit = getPenHitTarget(point);
            if (hit && hit.kind === 'handle') {
              state.drag.mode = 'pen-handle';
              state.drag.penAnchorIndex = hit.anchorIndex;
              state.drag.penHandleType = hit.handleType;
              state.pen.selectedAnchorIndex = hit.anchorIndex;
              state.pen.selectedHandle = { anchorIndex: hit.anchorIndex, handleType: hit.handleType };
              renderStage();
            } else if (hit && hit.kind === 'anchor') {
              state.drag.mode = 'pen-anchor';
              state.drag.penAnchorIndex = hit.anchorIndex;
              state.pen.selectedAnchorIndex = hit.anchorIndex;
              state.pen.selectedHandle = null;
              renderStage();
            } else if (isNearPenPathStart(point, 10)) {
              if (closePenPath()) {
                state.drag.active = false;
                state.drag.pointerId = null;
                renderStage();
                setStatus('Pen path closed. Press Enter to apply.', 'success');
                return;
              }
              state.drag.active = false;
              state.drag.pointerId = null;
              return;
            } else {
              state.drag.mode = 'pen-new-anchor';
              state.drag.penAnchorIndex = addPenAnchor(point);
              renderStage();
            }
          } else if (state.activeTool === 'path-select') {
            if (!pathSelectionTool || typeof pathSelectionTool.handlePointerDown !== 'function') {
              state.drag.active = false;
              state.drag.pointerId = null;
              return;
            }
            const result = pathSelectionTool.handlePointerDown(point, event) || {};
            if (result.handled !== true) {
              state.drag.active = false;
              state.drag.pointerId = null;
              return;
            }
            if (result.startDrag === false) {
              state.drag.active = false;
              state.drag.pointerId = null;
              return;
            }
            state.drag.mode = 'path-select';
          } else if (state.activeTool === 'hand') {
            if (!handTool || typeof handTool.handlePointerDown !== 'function') {
              state.drag.active = false;
              state.drag.pointerId = null;
              return;
            }
            const result = handTool.handlePointerDown(point, event) || {};
            if (result.handled !== true || result.startDrag === false) {
              state.drag.active = false;
              state.drag.pointerId = null;
              return;
            }
            state.drag.mode = 'hand';
            els.canvas.classList.add('is-dragging');
          } else if (state.activeTool === 'zoom') {
            if (!zoomTool || typeof zoomTool.handlePointerDown !== 'function') {
              state.drag.active = false;
              state.drag.pointerId = null;
              return;
            }
            const result = zoomTool.handlePointerDown(point, event) || {};
            if (result.handled !== true) {
              state.drag.active = false;
              state.drag.pointerId = null;
              return;
            }
            if (result.startDrag === false) {
              state.drag.active = false;
              state.drag.pointerId = null;
              return;
            }
            state.drag.mode = 'zoom';
          } else if (state.activeTool === 'type') {
            if (!state.image || !typeTool || typeof typeTool.handlePointerDown !== 'function') {
              state.drag.active = false;
              state.drag.pointerId = null;
              return;
            }
            const result = typeTool.handlePointerDown(point, event) || {};
            if (result.handled !== true) {
              state.drag.active = false;
              state.drag.pointerId = null;
              return;
            }
            state.drag.mode = 'type';
            if (result.startDrag === false) {
              state.drag.active = false;
              state.drag.pointerId = null;
              return;
            }
          } else {
            if (!state.image) {
              state.drag.active = false;
              state.drag.pointerId = null;
              return;
            }
            if (state.activeTool === 'move' && autoSelectController && typeof autoSelectController.tryStartFromMoveTool === 'function') {
              const autoSelectResult = autoSelectController.tryStartFromMoveTool(point, event) || {};
              if (autoSelectResult.handled === true) {
                if (autoSelectResult.startDrag === false) {
                  state.drag.active = false;
                  state.drag.pointerId = null;
                  return;
                }
                state.drag.mode = autoSelectResult.dragMode || null;
                if (state.drag.mode === 'hand' || state.drag.mode === 'move') {
                  els.canvas.classList.add('is-dragging');
                }
                try { els.canvas.setPointerCapture(event.pointerId); } catch (_) {}
                return;
              }
            }
            state.drag.mode = 'move';
            els.canvas.classList.add('is-dragging');
          }
          try { els.canvas.setPointerCapture(event.pointerId); } catch (_) {}
        });

        els.canvas.addEventListener('pointermove', function (event) {
          const point = getCanvasCoordsFromPointerEvent(event);
          if (!point) return;
          if (!state.drag.active) {
            if (state.activeTool === 'pen') {
              state.pen.previewPoint = point;
              renderStage();
            }
            return;
          }
          if (state.drag.pointerId !== null && event.pointerId !== state.drag.pointerId) return;
          const dx = point.x - state.drag.lastX;
          const dy = point.y - state.drag.lastY;
          state.drag.lastX = point.x;
          state.drag.lastY = point.y;
          if (state.drag.mode === 'marquee') {
            setSelectionFromPoints(state.drag.startX, state.drag.startY, point.x, point.y, !!event.shiftKey);
            renderStage();
            return;
          }
          if (state.drag.mode === 'lasso') {
            const points = state.drag.lassoPoints || [];
            const lastPoint = points[points.length - 1];
            if (!lastPoint || distanceBetweenPoints(lastPoint, point) >= 3) {
              points.push(clonePoint(point));
              state.drag.lassoPoints = points;
              state.selection = createLassoSelectionFromPoints(points, false);
              renderStage();
            }
            return;
          }
          if (state.drag.mode === 'crop') {
            state.cropBox = createCropBoxFromPoints(state.drag.startX, state.drag.startY, point.x, point.y, !!event.shiftKey);
            renderStage();
            return;
          }
          if (state.drag.mode === 'heal') {
            if (applySpotHealAtCanvasPoint(point.x, point.y)) {
              state.healBrush.activeStroke = true;
              renderStage();
            }
            return;
          }
          if (state.drag.mode === 'brush') {
            if (applyBrushAtCanvasPoint(point.x, point.y)) {
              state.brush.activeStroke = true;
              renderStage();
            }
            return;
          }
          if (state.drag.mode === 'eraser') {
            if (applyEraserAtCanvasPoint(point.x, point.y)) {
              state.eraser.activeStroke = true;
              renderStage();
            }
            return;
          }
          if (state.drag.mode === 'blur') {
            if (applyBlurAtCanvasPoint(point.x, point.y)) {
              state.blur.activeStroke = true;
              renderStage();
            }
            return;
          }
          if (state.drag.mode === 'dodge') {
            if (applyDodgeAtCanvasPoint(point.x, point.y)) {
              state.dodge.activeStroke = true;
              renderStage();
            }
            return;
          }
          if (state.drag.mode === 'gradient') {
            setGradientPreviewFromPoints(state.drag.startX, state.drag.startY, point.x, point.y);
            renderStage();
            return;
          }
          if (state.drag.mode === 'rectangle-create' || state.drag.mode === 'rectangle-move' || state.drag.mode === 'rectangle-resize') {
            const shape = getRectangleShapeById(state.drag.rectShapeId);
            if (!shape) return;
            const mapped = getImagePointFromCanvasPoint(point.x, point.y, true);
            if (!mapped) return;
            if (state.drag.mode === 'rectangle-create') {
              if (updateRectangleShapeFromImagePoints(shape, state.drag.rectStartImagePoint, mapped, !!event.shiftKey)) {
                if (!state.drag.rectMoved && (Math.abs(point.x - state.drag.startX) + Math.abs(point.y - state.drag.startY)) >= 1.25) {
                  state.drag.rectMoved = true;
                }
                renderStage();
              }
              return;
            }
            if (state.drag.mode === 'rectangle-move') {
              if (moveRectangleShapeFromDrag(shape, state.drag.rectStartGeom, state.drag.rectStartImagePoint, mapped)) {
                if (!state.drag.rectMoved && (Math.abs(point.x - state.drag.startX) + Math.abs(point.y - state.drag.startY)) >= 1.25) {
                  state.drag.rectMoved = true;
                }
                renderStage();
              }
              return;
            }
            if (state.drag.mode === 'rectangle-resize') {
              if (resizeRectangleShapeFromHandle(shape, state.drag.rectStartGeom, state.drag.rectHandle, mapped, !!event.shiftKey)) {
                if (!state.drag.rectMoved && (Math.abs(point.x - state.drag.startX) + Math.abs(point.y - state.drag.startY)) >= 1.25) {
                  state.drag.rectMoved = true;
                }
                updateRectangleControlsUi();
                renderStage();
              }
              return;
            }
          }
          if (state.drag.mode === 'pen-new-anchor') {
            const anchor = getPenAnchorAt(state.drag.penAnchorIndex);
            if (!anchor) return;
            let handlePoint = point;
            if (event.shiftKey) handlePoint = snapPointToAngle(anchor, point, 45);
            if (event.altKey) {
              setPenHandlePos(anchor, 'out', clonePoint(handlePoint));
              setPenHandlePos(anchor, 'in', null);
              maybeRemoveTinyPenHandles(anchor);
            } else {
              setPenHandle(state.drag.penAnchorIndex, 'out', clonePoint(handlePoint), true);
            }
            if (!state.drag.penMoved && distanceBetweenPoints(anchor, handlePoint) >= 1.25) {
              state.drag.penMoved = true;
            }
            renderStage();
            return;
          }
          if (state.drag.mode === 'pen-anchor') {
            if (movePenAnchor(state.drag.penAnchorIndex, dx, dy)) {
              if (!state.drag.penMoved && (Math.abs(point.x - state.drag.startX) + Math.abs(point.y - state.drag.startY)) >= 1.25) {
                state.drag.penMoved = true;
              }
              renderStage();
            }
            return;
          }
          if (state.drag.mode === 'pen-handle') {
            const anchor = getPenAnchorAt(state.drag.penAnchorIndex);
            if (!anchor) return;
            let handlePoint = point;
            if (event.shiftKey) handlePoint = snapPointToAngle(anchor, point, 45);
            if (setPenHandle(state.drag.penAnchorIndex, state.drag.penHandleType, handlePoint, !event.altKey)) {
              state.pen.selectedAnchorIndex = state.drag.penAnchorIndex;
              state.pen.selectedHandle = { anchorIndex: state.drag.penAnchorIndex, handleType: state.drag.penHandleType };
              if (!state.drag.penMoved && distanceBetweenPoints(anchor, handlePoint) >= 1.25) {
                state.drag.penMoved = true;
              }
              renderStage();
            }
            return;
          }
          if (state.drag.mode === 'path-select') {
            if (pathSelectionTool && typeof pathSelectionTool.handlePointerMove === 'function') {
              pathSelectionTool.handlePointerMove(point, event);
            }
            return;
          }
          if (state.drag.mode === 'hand') {
            if (handTool && typeof handTool.handlePointerMove === 'function') {
              handTool.handlePointerMove(point, event);
            }
            return;
          }
          if (state.drag.mode === 'zoom') {
            if (zoomTool && typeof zoomTool.handlePointerMove === 'function') {
              zoomTool.handlePointerMove(point, event);
            }
            return;
          }
          if (state.drag.mode === 'type') {
            if (typeTool && typeof typeTool.handlePointerMove === 'function') {
              typeTool.handlePointerMove(point, event);
            }
            return;
          }
          panImage(dx, dy);
        });

        function endCanvasDrag(event) {
          if (!state.drag.active) return;
          if (event && state.drag.pointerId !== null && event.pointerId !== state.drag.pointerId) return;
          const mode = state.drag.mode;
          const penAnchorIndex = state.drag.penAnchorIndex;
          const penHandleType = state.drag.penHandleType;
          const penMoved = !!state.drag.penMoved;
          const rectShapeId = state.drag.rectShapeId;
          const rectHandle = state.drag.rectHandle;
          const rectMoved = !!state.drag.rectMoved;
          state.drag.active = false;
          state.drag.pointerId = null;
          state.drag.mode = null;
          state.drag.penAnchorIndex = -1;
          state.drag.penHandleType = null;
          state.drag.penMoved = false;
          state.drag.rectShapeId = null;
          state.drag.rectHandle = null;
          state.drag.rectMoved = false;
          state.drag.rectStartImagePoint = null;
          state.drag.rectStartGeom = null;
          const lassoPoints = state.drag.lassoPoints;
          state.drag.lassoPoints = null;
          els.canvas.classList.remove('is-dragging');
          if (mode === 'marquee' && state.selection) {
            if (!isSelectionUsable(state.selection)) {
              state.selection = null;
              renderStage();
              setStatus('Selection cleared.', 'info');
            } else {
              setStatus('Marquee selection created (' + Math.round(state.selection.width) + 'x' + Math.round(state.selection.height) + ').', 'success');
              pushHistory('Marquee selection');
            }
          } else if (mode === 'lasso') {
            if (Array.isArray(lassoPoints) && lassoPoints.length >= 2) {
              const lastPoint = lassoPoints[lassoPoints.length - 1];
              if (!lastPoint || !event || distanceBetweenPoints(lastPoint, getCanvasCoordsFromPointerEvent(event) || lastPoint) > 1.5) {
                if (event) {
                  const endPoint = getCanvasCoordsFromPointerEvent(event);
                  if (endPoint) lassoPoints.push(clonePoint(endPoint));
                }
              }
            }

            state.selection = createLassoSelectionFromPoints(lassoPoints || [], true);
            if (!isSelectionUsable(state.selection)) {
              state.selection = null;
              renderStage();
              setStatus('Lasso selection cleared.', 'info');
            } else {
              let lassoAutoRefined = false;
              if (autoSelectController && typeof autoSelectController.tryRefineLassoSelection === 'function') {
                const refineResult = autoSelectController.tryRefineLassoSelection(state.selection, { source: 'lasso' }) || {};
                lassoAutoRefined = !!refineResult.refined;
              }
              renderStage();
              if (!lassoAutoRefined) {
                setStatus('Lasso selection created (' + Math.round(state.selection.width) + 'x' + Math.round(state.selection.height) + ').', 'success');
              }
              pushHistory(lassoAutoRefined ? 'Lasso auto-select snap' : 'Lasso selection');
            }
          } else if (mode === 'crop') {
            if (!isCropBoxUsable(state.cropBox)) {
              state.cropBox = null;
              renderStage();
              setStatus('Crop box cleared.', 'info');
            } else {
              renderStage();
              setStatus('Crop box ready (' + Math.round(state.cropBox.width) + 'x' + Math.round(state.cropBox.height) + '). Press Enter to apply.', 'success');
            }
          } else if (mode === 'heal') {
            if (state.healBrush.activeStroke) {
              pushHistory('Spot heal');
              setStatus('Spot healing applied.', 'success');
            }
            state.healBrush.activeStroke = false;
            state.healBrush.lastSourceOffset = null;
          } else if (mode === 'brush') {
            if (state.brush.activeStroke) {
              pushHistory('Brush stroke');
              setStatus('Brush stroke applied.', 'success');
            }
            state.brush.activeStroke = false;
            state.brush.lastPoint = null;
          } else if (mode === 'eraser') {
            if (state.eraser.activeStroke) {
              pushHistory('Erase stroke');
              setStatus('Eraser stroke applied.', 'success');
            }
            state.eraser.activeStroke = false;
            state.eraser.lastPoint = null;
          } else if (mode === 'blur') {
            if (state.blur.activeStroke) {
              pushHistory('Blur stroke');
              setStatus('Blur applied.', 'success');
            }
            state.blur.activeStroke = false;
          } else if (mode === 'dodge') {
            if (state.dodge.activeStroke) {
              pushHistory('Dodge stroke');
              setStatus('Dodge applied.', 'success');
            }
            state.dodge.activeStroke = false;
          } else if (mode === 'gradient') {
            const preview = state.gradient.preview;
            const applied = isGradientPreviewUsable(preview)
              ? applyGradientFromCanvasPoints(preview.start.x, preview.start.y, preview.end.x, preview.end.y)
              : false;
            state.gradient.preview = null;
            renderStage();
            if (applied) {
              pushHistory('Gradient fill');
              setStatus('Gradient applied.', 'success');
            } else {
              setStatus('Gradient cancelled.', 'info');
            }
          } else if (mode === 'rectangle-create') {
            const shape = getRectangleShapeById(rectShapeId);
            if (!shape) {
              updateRectangleControlsUi();
              renderStage();
            } else {
              const m = getRectangleCanvasMetrics(shape);
              const tiny = !m || m.width < 3 || m.height < 3;
              if (tiny) {
                const idx = getRectangleShapes().findIndex(function (s) { return !!s && s.id === rectShapeId; });
                if (idx >= 0) state.rectangleTool.shapes.splice(idx, 1);
                if (state.rectangleTool.selectedId === rectShapeId) state.rectangleTool.selectedId = null;
                updateRectangleControlsUi();
                renderStage();
                setStatus('Rectangle creation cancelled.', 'info');
              } else {
                state.dirty = true;
                updateRectangleControlsUi();
                renderStage();
                pushHistory('Rectangle shape');
                setStatus('Rectangle created (' + Math.round(shape.width) + 'x' + Math.round(shape.height) + ').', 'success');
              }
            }
          } else if (mode === 'rectangle-move') {
            const shape = getRectangleShapeById(rectShapeId);
            updateRectangleControlsUi();
            renderStage();
            if (shape && rectMoved) {
              state.dirty = true;
              pushHistory('Move rectangle');
              setStatus('Rectangle moved.', 'success');
            } else if (shape) {
              setStatus('Rectangle selected. Drag to move, drag handles to resize.', 'success');
            }
          } else if (mode === 'rectangle-resize') {
            const shape = getRectangleShapeById(rectShapeId);
            updateRectangleControlsUi();
            renderStage();
            if (shape && rectMoved) {
              state.dirty = true;
              pushHistory('Resize rectangle');
              setStatus('Rectangle resized' + (rectHandle ? ' (' + rectHandle.toUpperCase() + ')' : '') + '.', 'success');
            } else if (shape) {
              setStatus('Rectangle selected.', 'success');
            }
          } else if (mode === 'pen-new-anchor') {
            const anchor = getPenAnchorAt(penAnchorIndex);
            if (anchor) {
              if (!penMoved) {
                anchor.in = null;
                anchor.out = null;
              } else {
                maybeRemoveTinyPenHandles(anchor);
              }
              state.pen.selectedAnchorIndex = penAnchorIndex;
              state.pen.selectedHandle = null;
              if (event) {
                const endPoint = getCanvasCoordsFromPointerEvent(event);
                if (endPoint) state.pen.previewPoint = endPoint;
              }
              renderStage();
              const path = state.pen.path;
              const count = path && Array.isArray(path.points) ? path.points.length : 0;
              setStatus('Pen anchor added (' + count + ' total). ' + (penMoved ? 'Bezier handles created.' : 'Drag while placing for handles.'), 'success');
            }
          } else if (mode === 'pen-anchor') {
            const path = state.pen.path;
            if (!penMoved && path && !path.closed && penAnchorIndex === 0 && path.points.length >= 2) {
              if (closePenPath()) {
                renderStage();
                setStatus('Pen path closed. Press Enter to apply.', 'success');
              } else {
                renderStage();
              }
            } else {
              state.pen.selectedAnchorIndex = penAnchorIndex;
              state.pen.selectedHandle = null;
              if (event) {
                const endPoint = getCanvasCoordsFromPointerEvent(event);
                if (endPoint) state.pen.previewPoint = endPoint;
              }
              renderStage();
              if (penMoved) setStatus('Pen anchor moved.', 'success');
            }
          } else if (mode === 'pen-handle') {
            const anchor = getPenAnchorAt(penAnchorIndex);
            if (anchor) maybeRemoveTinyPenHandles(anchor);
            state.pen.selectedAnchorIndex = penAnchorIndex;
            state.pen.selectedHandle = penHandleType ? { anchorIndex: penAnchorIndex, handleType: penHandleType } : null;
            if (event) {
              const endPoint = getCanvasCoordsFromPointerEvent(event);
              if (endPoint) state.pen.previewPoint = endPoint;
            }
            renderStage();
            if (penMoved) setStatus('Pen handle adjusted.', 'success');
          } else if (mode === 'path-select') {
            if (pathSelectionTool && typeof pathSelectionTool.handlePointerUp === 'function') {
              pathSelectionTool.handlePointerUp(event ? getCanvasCoordsFromPointerEvent(event) : null, event);
            }
          } else if (mode === 'hand') {
            if (handTool && typeof handTool.handlePointerUp === 'function') {
              handTool.handlePointerUp(event ? getCanvasCoordsFromPointerEvent(event) : null, event);
            }
          } else if (mode === 'zoom') {
            if (zoomTool && typeof zoomTool.handlePointerUp === 'function') {
              zoomTool.handlePointerUp(event ? getCanvasCoordsFromPointerEvent(event) : null, event);
            }
          } else if (mode === 'type') {
            if (typeTool && typeof typeTool.handlePointerUp === 'function') {
              const endPoint = event ? getCanvasCoordsFromPointerEvent(event) : null;
              typeTool.handlePointerUp(endPoint, event);
            }
          }
          if (event) {
            try { els.canvas.releasePointerCapture(event.pointerId); } catch (_) {}
          }
        }

        els.canvas.addEventListener('pointerup', endCanvasDrag);
        els.canvas.addEventListener('pointercancel', endCanvasDrag);
        els.canvas.addEventListener('lostpointercapture', function () {
          state.drag.active = false;
          state.drag.pointerId = null;
          state.drag.mode = null;
          state.drag.lassoPoints = null;
          state.drag.penAnchorIndex = -1;
          state.drag.penHandleType = null;
          state.drag.penMoved = false;
          state.drag.rectShapeId = null;
          state.drag.rectHandle = null;
          state.drag.rectMoved = false;
          state.drag.rectStartImagePoint = null;
          state.drag.rectStartGeom = null;
          state.healBrush.activeStroke = false;
          state.healBrush.lastSourceOffset = null;
          state.brush.activeStroke = false;
          state.brush.lastPoint = null;
          state.eraser.activeStroke = false;
          state.eraser.lastPoint = null;
          state.blur.activeStroke = false;
          state.dodge.activeStroke = false;
          clearGradientPreview();
          if (handTool && typeof handTool.cancelDrag === 'function') handTool.cancelDrag();
          if (zoomTool && typeof zoomTool.cancelDrag === 'function') zoomTool.cancelDrag();
          if (pathSelectionTool && typeof pathSelectionTool.cancelDrag === 'function') pathSelectionTool.cancelDrag();
          if (typeTool && typeof typeTool.cancelDrag === 'function') typeTool.cancelDrag();
          els.canvas.classList.remove('is-dragging');
          renderStage();
        });
      }

      document.addEventListener('click', closeFileMenu);
      document.addEventListener('keydown', function (event) {
        const key = String(event.key || '').toLowerCase();
        const mod = event.ctrlKey || event.metaKey;
        const activeEl = document.activeElement;
        const activeTag = activeEl && activeEl.tagName ? String(activeEl.tagName).toUpperCase() : '';
        const isTypingTarget = !!(activeEl && (activeEl.isContentEditable || activeTag === 'INPUT' || activeTag === 'TEXTAREA' || activeTag === 'SELECT'));

        if (key === 'escape') {
          closeFileMenu();
          if (state.cropBox) {
            clearCropBox({ silent: false });
            return;
          }
          if (state.selection) {
            clearSelection({ silent: false });
            return;
          }
          if (clearGradientPreview()) {
            renderStage();
            setStatus('Gradient guide cleared.', 'info');
            return;
          }
          if (clearRectangleSelection({ silent: false })) {
            return;
          }
          if (pathSelectionTool && typeof pathSelectionTool.clearSelection === 'function' && pathSelectionTool.clearSelection({ silent: false })) {
            return;
          }
          if (state.activeTool === 'pen' && hasPenPath()) {
            clearPenPath({ silent: false });
            return;
          }
          return;
        }

        if (!mod && !event.altKey && key === 'enter') {
          if (state.activeTool === 'crop' && isCropBoxUsable(state.cropBox)) {
            event.preventDefault();
            applyCropToImage();
            return;
          }
          if ((state.activeTool === 'pen' || state.activeTool === 'path-select') && isPenPathUsable(state.pen.path)) {
            event.preventDefault();
            applyPenPathToImage();
            return;
          }
        }

        if (!mod && !event.altKey && state.activeTool === 'type' && typeTool && typeof typeTool.handleKeyDown === 'function') {
          if (typeTool.handleKeyDown(event)) return;
        }
        if (!isTypingTarget && !mod && !event.altKey && state.activeTool === 'path-select' && pathSelectionTool && typeof pathSelectionTool.handleKeyDown === 'function') {
          if (pathSelectionTool.handleKeyDown(event)) return;
        }

        if (!mod && !event.altKey && (key === 'backspace' || key === 'delete')) {
          if (!isTypingTarget && state.activeTool === 'rectangle' && state.rectangleTool && state.rectangleTool.selectedId) {
            event.preventDefault();
            deleteSelectedRectangleShape({ silent: false });
            return;
          }
          if (!isTypingTarget && state.activeTool === 'pen' && hasPenPath()) {
            event.preventDefault();
            if (removeSelectedOrLastPenAnchor()) {
              renderStage();
              if (hasPenPath()) {
                const remaining = state.pen.path && Array.isArray(state.pen.path.points) ? state.pen.path.points.length : 0;
                setStatus('Pen anchor removed (' + remaining + ' remaining).', 'success');
              } else {
                setStatus('Pen path cleared.', 'info');
              }
            }
            return;
          }
        }

        if (!isTypingTarget && !mod && !event.altKey) {
          if (key === 'm') {
            event.preventDefault();
            setActiveTool('marquee');
            return;
          }
          if (key === 'l') {
            event.preventDefault();
            setActiveTool('lasso');
            return;
          }
          if (key === 'c') {
            event.preventDefault();
            setActiveTool('crop');
            return;
          }
          if (key === 'j') {
            event.preventDefault();
            setActiveTool('heal');
            return;
          }
          if (key === 'b') {
            event.preventDefault();
            setActiveTool('brush');
            return;
          }
          if (key === 'e') {
            event.preventDefault();
            setActiveTool('eraser');
            return;
          }
          if (key === 'g') {
            event.preventDefault();
            setActiveTool('gradient');
            return;
          }
          if (key === 'u') {
            event.preventDefault();
            setActiveTool('rectangle');
            return;
          }
          if (key === 'r') {
            event.preventDefault();
            setActiveTool('blur');
            return;
          }
          if (key === 'o') {
            event.preventDefault();
            setActiveTool('dodge');
            return;
          }
          if (key === 'p') {
            event.preventDefault();
            setActiveTool('pen');
            return;
          }
          if (key === 'a') {
            event.preventDefault();
            setActiveTool('path-select');
            return;
          }
          if (key === 'd') {
            event.preventDefault();
            resetDefaultColors();
            return;
          }
          if (key === 'h') {
            event.preventDefault();
            setActiveTool('hand');
            return;
          }
          if (key === 'z') {
            event.preventDefault();
            setActiveTool('zoom');
            return;
          }
          if (key === 't') {
            event.preventDefault();
            setActiveTool('type');
            return;
          }
          if (key === 'v') {
            event.preventDefault();
            setActiveTool('move');
            return;
          }
        }

        if (!mod) return;
        if (event.altKey) return;

        if (key === 'o') {
          event.preventDefault();
          importImage();
        } else if (key === 's') {
          event.preventDefault();
          saveChanges();
        } else if (key === 'n') {
          event.preventDefault();
          newBlankCanvas();
        } else if (key === '0') {
          if (!state.image) return;
          event.preventDefault();
          fitImageToCanvas();
          setStatus('View fit to canvas.', 'success');
        } else if (key === '1') {
          if (!state.image) return;
          event.preventDefault();
          setActualSize();
          setStatus('Actual size (100%).', 'success');
        } else if (key === '+' || key === '=' ) {
          if (!state.image) return;
          event.preventDefault();
          const center = getCanvasCenter();
          zoomAtCanvasPoint(center.x, center.y, 1.1);
        } else if (key === '-' || key === '_') {
          if (!state.image) return;
          event.preventDefault();
          const center = getCanvasCenter();
          zoomAtCanvasPoint(center.x, center.y, 1 / 1.1);
        }
      });

      if (typeof ResizeObserver === 'function' && els.canvasArea) {
        const resizeObserver = new ResizeObserver(function () {
          resizeCanvasToStage();
        });
        resizeObserver.observe(els.canvasArea);
        state.resizeObserver = resizeObserver;
      } else {
        window.addEventListener('resize', resizeCanvasToStage);
      }

      resizeCanvasToStage();
      renderGradientPresetButtons();
      updateGradientControlsUi();
      updateRectangleControlsUi();
      updateToolButtonsUi();
      updateCanvasToolClass();
      updateGradientControlsVisibility();
      updateRectangleControlsVisibility();
      drawCheckerPlaceholder();
      setStatus('Prototype UI (dummy controls) | File menu is active', 'info');
    })();
  </script>
</body>
</html>
